<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>C++ on lxulxu's blog</title><link>https://lxulxu.github.io/tags/c++/</link><description>Recent content in C++ on lxulxu's blog</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Fri, 05 Jul 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://lxulxu.github.io/tags/c++/index.xml" rel="self" type="application/rss+xml"/><item><title>C++中的push_back与emplace_back</title><link>https://lxulxu.github.io/posts/push_back_emplace_back/</link><pubDate>Fri, 05 Jul 2024 00:00:00 +0000</pubDate><guid>https://lxulxu.github.io/posts/push_back_emplace_back/</guid><description>1. 引言
C++标准库提供了push_back和emplace_back两种向容器末尾添加元素的方法。本文将深入分析这两个函数的区别、使用场景，以及在实际应用中的性能考虑。
2. 基本概念
2.1 push_back push_back有两个重载版本：
1void push_back(const T&amp;amp; value); 2void push_back(T&amp;amp;&amp;amp; value); 第一个版本复制元素，第二个版本移动元素。
2.2 emplace_back emplace_back是C++11引入的变参模板函数：
1template &amp;lt;class... Args&amp;gt; 2void emplace_back(Args&amp;amp;&amp;amp;... args); 它直接在容器中构造对象，参数被完美转发给元素的构造函数。
3. 主要区别
构造方式：push_back需要预先构造的对象，emplace_back在容器内构造对象。 参数传递：push_back接受对象，emplace_back接受构造函数参数。 效率：emplace_back可能避免不必要的临时对象创建和复制/移动操作。 灵活性：emplace_back可直接传递构造函数参数。 编译复杂度：emplace_back作为变参模板可能增加编译时间和内存使用。 4. 使用示例
4.1 简单类型
1std::vector&amp;lt;int&amp;gt; vec; 2vec.push_back(10); // push_back 足够简单高效 4.2 复杂对象构造
1std::vector&amp;lt;std::pair&amp;lt;int, std::string&amp;gt;&amp;gt; vec; 2// 使用 push_back 3vec.push_back(std::make_pair(1, &amp;#34;one&amp;#34;)); 4// 使用 emplace_back 5vec.emplace_back(1, &amp;#34;one&amp;#34;); // 更简洁，直接传递构造函数参数 4.3 不可移动类型
1std::vector&amp;lt;std::mutex&amp;gt; mutexes; 2mutexes.emplace_back(); // 可以工作，直接在容器中构造 mutex 3// mutexes.push_back(std::mutex()); // 编译错误，mutex 不可复制或移动 5.</description></item><item><title>C++安全指南</title><link>https://lxulxu.github.io/posts/cplusplus_security_guide/</link><pubDate>Sun, 28 Apr 2024 08:20:35 +0000</pubDate><guid>https://lxulxu.github.io/posts/cplusplus_security_guide/</guid><description>编程习惯 switch中应有default 不应在debug或错误信息中提供过多内容 不应该在客户端代码中硬编码对称加密秘钥 1 // Bad 2 char g_aes_key[] = {...}; 3 void Foo() { 4 .... 5 AES_func(g_aes_key, input_data, output_data); 6 } 1 // Good 2 char* g_aes_key; 3 void Foo() { 4 .... 5 AES_encrypt(g_aes_key, input_data, output_data); 6 } 7 void Init() { 8 g_aes_key = get_key_from_https(user_id, ...); 9 } 函数不可以返回栈上的变量的地址，而应当使用堆来传递非简单类型变量，强烈建议返回 string、vector 等类型。 1 // Bad 2 char* Foo(char* sz, int len){ 3 char a[300] = {0}; 4 if (len &amp;gt; 100) { 5 memcpy(a, sz, 100); 6 } 7 a[len] = &amp;#39;\0&amp;#39;; 8 return a; // WRONG 9 } 1 // Good 2 char* Foo(char* sz, int len) { 3 char* a = new char[300]; 4 if (len &amp;gt; 100) { 5 memcpy(a, sz, 100); 6 } 7 a[len] = &amp;#39;\0&amp;#39;; 8 return a; // OK 9 } 有逻辑联系的数组必须仔细检查 1 // Good 2 const int nWeekdays[] = {1, 2, 3, 4, 5, 6, 7}; 3 const char* sWeekdays[] = {&amp;#34;Mon&amp;#34;, &amp;#34;Tue&amp;#34;, &amp;#34;Wed&amp;#34;, &amp;#34;Thu&amp;#34;, &amp;#34;Fri&amp;#34;, &amp;#34;Sat&amp;#34;, &amp;#34;Sun&amp;#34;}; 4 assert(ARRAY_SIZE(nWeekdays) == ARRAY_SIZE(sWeekdays));//确保有关联的nWeekdays和sWeekdays数据统一 5 for (int x = 0; x &amp;lt; ARRAY_SIZE(sWeekdays); x++) { 6 if (strcmp(sWeekdays[x], input) == 0) { 7 return nWeekdays[x]; 8 } 9 } 在头文件、源代码、文档中列举的函数声明应当一致，不应当出现定义内容错位的情况 错误示例： foo.</description></item><item><title>《高质量C++编程指南》笔记</title><link>https://lxulxu.github.io/posts/high_quality_cpp_programming_notes/</link><pubDate>Sun, 04 Sep 2022 11:51:33 +0000</pubDate><guid>https://lxulxu.github.io/posts/high_quality_cpp_programming_notes/</guid><description>文件结构 头文件结构 1//版权和版本声明 2/* 3* Copyright (c) 2001,上海贝尔有限公司网络应用事业部 4* All rights reserved. 5* 6* 文件名称：graphics.h 7* 文件标识：见配置管理计划书 8* 摘 要：简要描述本文件的内容 9* 10* 当前版本：1.1 11* 作 者：输入作者（或修改者）名字 12* 完成日期：2001年7月20日 13* 14* 取代版本：1.0 15* 原作者 ：输入原作者（或修改者）名字 16* 完成日期：2001年5月10日 17*/ 18 19#ifndef GRAPHICS_H // 防止 graphics.h 被重复引用 20#define GRAPHICS_H 21#include &amp;lt;math.h&amp;gt; // 引用标准库的头文件 22... 23#include “myheader.h” // 引用非标准库的头文件 24... 25void Function1(...); // 全局函数声明 26... 27class Box // 类结构声明 28{ 29... 30}; 31#endif 版权和版本的声明 版权信息。 文件名称，标识符，摘要。 当前版本号，作者/修改者，完成日期。 版本历史信息。 预处理块 为了防止头文件被重复引用，应当用 ifndef/define/endif 结构产生预处理块</description></item></channel></rss>