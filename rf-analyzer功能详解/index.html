<!doctype html><html lang=en-us><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="IE=edge"><style type=text/css>body{font-family:monospace}</style><title>RF Analyzer 功能详解</title>
<link rel=stylesheet href=/css/style.css></head><body><header>===================<br>== <a href=https://lxulxu.github.io/>lxulxu's blog</a> ==<br>===================<div style=float:right>Hello there</div><br><p><nav><a href=/><b>Start</b></a>.
<a href=/posts/><b>Posts</b></a>.
<a href=/categories/><b>Categories</b></a>.
<a href=/tags/><b>Tags</b></a>.</nav></p></header><main><article><h1>RF Analyzer 功能详解</h1><b><time>02.06.27276 33:06</time></b>
<a href=/tags/xilinx>xilinx</a><div><h1 id=rf-adc>RF-ADC</h1><p><figure><img src=../assets/images/Y2023Q1/img-72.uyj3mknshqo.jpg alt=img-72></figure></p><h2 id=转换器设置converter-settings>转换器设置(Converter Settings)</h2><ul><li><p>校准模式(Calibration Mode)<figure><img src=../assets/images/Y2023Q1/img-151.4s8e5r0arfa0.jpg alt=img-151></figure>校准子系统由三个主要模块组成：</p><ul><li>时间交错偏移校准模块(OCB):校正每个子RF-ADC的<strong>DC偏移</strong></li><li>增益校准模块(GCB):校正交错子RF-ADC之间的<strong>增益差异</strong></li><li>时间偏移校准模块(TSCB):校正交错子RF-ADC之间的<strong>时间偏移</strong></li></ul><p>除了自动校准外，所有四个校准模块（OCB1、OCB2、GCB、TSCB）都可用于获取和设置用户系数。 应用程序读回校准解冻时生成的系数，并在需要时恢复它们； 这有助于在输入信号不满足校准要求时保持 RF-ADC 性能。 此功能适用于 IP 向导中的每个 RF-ADC。 启用此功能会增加 IP 的大小。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#75715e>//以下示例代码显示了 TSCB 的用户系数设置。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>u32 Status <span style=color:#f92672>=</span> XRFDC_FAILURE;
</span></span><span style=display:flex><span>XRFdc_Calibration_Coefficients Coeffs;
</span></span><span style=display:flex><span><span style=color:#75715e>//使用下面的样本系数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>Coeffs.Coeff0 <span style=color:#f92672>=</span> <span style=color:#ae81ff>146</span>;
</span></span><span style=display:flex><span>Coeffs.Coeff1 <span style=color:#f92672>=</span> <span style=color:#ae81ff>255</span>;
</span></span><span style=display:flex><span>Coeffs.Coeff2 <span style=color:#f92672>=</span> <span style=color:#ae81ff>255</span>;
</span></span><span style=display:flex><span>Coeffs.Coeff3 <span style=color:#f92672>=</span> <span style=color:#ae81ff>255</span>;
</span></span><span style=display:flex><span>Coeffs.Coeff4 <span style=color:#f92672>=</span> <span style=color:#ae81ff>113</span>;
</span></span><span style=display:flex><span>Coeffs.Coeff5 <span style=color:#f92672>=</span> <span style=color:#ae81ff>255</span>;
</span></span><span style=display:flex><span>Coeffs.Coeff6 <span style=color:#f92672>=</span> <span style=color:#ae81ff>255</span>
</span></span><span style=display:flex><span>Coeffs.Coeff7 <span style=color:#f92672>=</span> <span style=color:#ae81ff>255</span>;
</span></span><span style=display:flex><span>Status <span style=color:#f92672>=</span> XRFdc_SetCalCoeffients( RFdcInstPtr, Tile, Block,
</span></span><span style=display:flex><span>XRFDC_CAL_BLOCK_TSCB, <span style=color:#f92672>&amp;</span>Coeffs);
</span></span><span style=display:flex><span>If (Status <span style=color:#f92672>!=</span> XRFDC_SUCCESS) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>/*handle error*/</span>
</span></span><span style=display:flex><span>}  
</span></span></code></pre></div><p>使用<code>XRFdc_SetCalCoefficients</code> API 恢复校准系数会自动禁用实时校准。 提供 <code>XRFdc_DisableCoefficientsOverride</code> API 以禁用此用户系数覆盖模式并重新启用实时校准。 禁用实时校准时，实时端口校准冻结无效。</p><p><figure><img src=../assets/images/Y2023Q1/img-74.4auk0q3tcqw0.jpg alt=img-74></figure></p><ul><li>Mode 1:优化0.4* Fs 到Fs/2范围内信号，对于输入频率Fsamp/2(Nyquist) ± 10%是最佳的。</li><li>Mode 2:优化0 到0.4* Fs范围内信号，适用于其他范围输入频率。</li></ul></li><li><p>奈奎斯特区(Nyquist Zone):每个RF-ADC通道可以在第一或第二奈奎斯特区采样信号。第一奈奎斯特区被定义为信号在0和Fs/2之间，第二奈奎斯特区被定义为信号在Fs/2和Fs之间。为了确保RF-ADC的性能最佳，RF-ADC配置应指示预期的操作区域。只要信号符合RF-ADC输入带宽要求，也可以使用其他奈奎斯特区。第1，3，5 &mldr;区称为奇数区，第2，4 &mldr;区称为偶数区。1 用于奇数区域，2 用于偶数区域。</p></li><li><p>校准冻结(Freeze):用于冻结每个通道的交错校准。当模拟输入电压过高或相关的<code>int_cal_freeze</code>输入被断时，校准将被冻结。绿灯表示冻结状态。冻结按键可冻结或解冻交错校准。</p></li><li><p>禁用引脚(Disable Pin):禁用校准冻结实时端口控制</p></li><li><p>信号衰减(Attenuation):每个ADC通道片内数字步进衰减器(Digital Step Attenuator, DSA)衰减值(以dB为单位)，disable pin功能可以禁用DSA引脚控制。</p></li><li><p>抖动(Dither):除非采样率低于最大采样率0.75倍，否则启用。</p></li><li><p>输入共模电压范围(VCM)</p></li></ul><h2 id=阈值检测threshold-detection>阈值检测(Threshold Detection)</h2><p>每个 RF-ADC 通道有两个实时输出信号，具有过量程(Over Range)和过压(Over Voltage)功能，当模拟输入超过限度的时候会给出中断，同时上报给通信总线，以便直接访问 PL 设计。下图显示了阈值、过量程和过压电平以及随着输入模拟信号的增加这些电平的响应。<figure><img src=../assets/images/Y2023Q1/img-152.47kp0c0pnvm0.jpg alt=img-152></figure></p><ul><li><p>Mode</p><table><thead><tr><th>模式</th><th>功能</th></tr></thead><tbody><tr><td>Off</td><td>阈值电路禁用，状态输出为低。</td></tr><tr><td>Sticky over</td><td>当来自RF-ADC的数据超过上限阈值时，阈值状态信号为高电平，状态一直保持到发送清除操作为止。</td></tr><tr><td>Sticky under</td><td>当来自RF-ADC的数据在用户指定的时间或延迟内保持低于下限阈值时，阈值状态信号为高电平，状态一直保持到发送清除操作为止。使用RFdc驱动程序API设置计数器，使用此机制可防止触发阈值事件的短时间偏移。</td></tr><tr><td>Hysteresis</td><td>当超过设定的上限阈值时设置状态输出，当信号在用户指定的延迟值期间保持低于下限阈值时清除。下限阈值的延迟值由32位计数器定义，使用RFdc驱动程序API设置计数器，延迟为阈值检测增加了滞后，以防止触发阈值事件的短时间偏移。</td></tr></tbody></table></li><li><p>Under Level:低阈值</p></li><li><p>Over Level:高阈值</p></li><li><p>Delay:延迟值</p></li></ul><p>使用 RFdc 驱动程序 API 配置阈值电平和延迟值示例如下。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#75715e>// Initial Setup
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>XRFdc_Threshold_Settings Threshold_Settings;
</span></span><span style=display:flex><span>Threshold_Settings.UpdateThreshold <span style=color:#f92672>=</span> XRFDC_UPDATE_THRESHOLD_BOTH; <span style=color:#75715e>// Setup
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>values
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> threshold <span style=color:#ae81ff>0</span> and <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>Threshold_Settings.ThresholdMode[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> XRFDC_TRSHD_STICKY_UNDER; <span style=color:#75715e>// Set
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>threshold0
</span></span><span style=display:flex><span>mode to Sticky Under
</span></span><span style=display:flex><span>Threshold_Settings.ThresholdUnderVal[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1000</span>; <span style=color:#75715e>// Measured in 14-bit
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>unsigned</span> LSBs
</span></span><span style=display:flex><span>Threshold_Settings.ThresholdAvgVal[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>; <span style=color:#75715e>// Data must be below lower
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>threshold <span style=color:#66d9ef>for</span> <span style=color:#ae81ff>10</span><span style=color:#f92672>*</span><span style=color:#ae81ff>8</span> <span style=color:#ae81ff>4</span> GSPS RF<span style=color:#f92672>-</span>ADC samples
</span></span><span style=display:flex><span><span style=color:#75715e>// Write threshold values to the selected Tile / RF-ADC
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>XRFdc_SetThresholdSettings(ptr, Tile, Block, <span style=color:#f92672>&amp;</span>Threshold_Settings);
</span></span></code></pre></div><h2 id=抽取设置decimation-settings>抽取设置(Decimation Settings)</h2><p>降采样滤波器（Decimation Filter）将高采样率信号降采样到较低采样率。通过将输入信号的带宽限制到降采样后的采样率的一半，然后将其下采样来减少数据量。降采样滤波器通常由两部分组成：抗混叠滤波器和下采样器。抗混叠滤波器通过降低输入信号的带宽，以避免在下采样时出现混叠误差，而下采样器则将信号降采样到所需的采样率。</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>OFF</td><td>滤波器被禁用，RF-ADC 不可用</td></tr><tr><td>1x</td><td>滤波器被绕过</td></tr><tr><td>2x</td><td>　2倍抽取，80% Nyquist 通带</td></tr><tr><td>4x</td><td>4倍抽取，80% Nyquist 通带</td></tr><tr><td>8x</td><td>8倍抽取，80% Nyquist 通带</td></tr></tbody></table><p>RFdc 驱动程序 API 可用于使用以下代码获取 IP 内核中设置的抽取率。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#75715e>//获取 Tile0、DDC Block1 的抽取因子
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> Tile <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>u32 Block <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>u32 Decimation_Factor;
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span>( XRFdc_GetDecimationFactor (ptr, Tile, Block, <span style=color:#f92672>&amp;</span>DecimationFactor) <span style=color:#f92672>==</span> XST_SUCCESS) {
</span></span><span style=display:flex><span>	xil_printf(<span style=color:#e6db74>&#34;ADC Tile%1d,%1d Decimation Factor is: %d&#34;</span>, Tile, Block,Decimation_Factor);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h1 id=rf-dac>RF-DAC</h1><p><figure><img src=../assets/images/Y2023Q1/img-81.7kckidky6ms0.jpg alt=img-81></figure></p><h2 id=转换器设置converter-settings-1>转换器设置(Converter Settings)</h2><ul><li>数据通路模式(DataPath):四种可用模式</li></ul><ul><li>解码模式(Decoder Mode):选择要优化的性能：噪声基底或线性。必须为通信应用选择噪声基底优化。宽带调制信号推荐使用低噪声模式。</li><li>奈奎斯特区(Nyquist Zone):选择信号将位于哪个奈奎斯特区域，1正常模式，2混合模式。<figure><img src=../assets/images/Y2023Q1/img-58.6mswppffpl40.jpg alt=img-58></figure><ul><li>正常模式:蓝线表示理想的RF-DAC输出陡峭的sinc响应。在这种模式下，第二奈奎斯特区中的输出图像将被严重衰减。对于此模式，可用反sinc滤波器来补偿第一奈奎斯特区的衰减。</li><li>混合模式:红线表示理想的RF-DAC输出响应。在这种模式下，第二奈奎斯特区中的输出功率显著增加，并且在大多数区域中也具有近似平坦的响应。可以在Vivado IDE中设置奈奎斯特区。由于sinc响应衰减和可能的带宽衰减，通常不会将RF-DAC在高于2的奈奎斯特区操作。</li></ul></li><li>当前值(Current):当前可变输出功率(variable output power, VOP)值</li></ul><h2 id=反sinc补偿inverse-sinc-settings>反Sinc补偿(Inverse Sinc Settings)</h2><p>模拟输出响应特性更接近sin(x)/x (冲击响应)，因此如果后级想取得比较平坦的系统响应需要较大的带宽。而做一个比较宽的平坦的模拟滤波器既不经济也不实惠，因此需要在DAC的输出级之前添加一级反sinc滤波器。可以认为和高速串行总线的预加重类似，通过提高信号高频分量的能量来抵消来自后端滤波器在过渡带增益不足的影响。<figure><img src=../assets/images/Y2023Q1/img-59.4087xmd6kx40.jpg alt=img-59></figure>蓝色线代表滤波器本身的频率响应。 可以看出，它随频率增加以补偿输出的 sinc 响应，如红线所示。 复合输出响应由黄色迹线给出，并显示高达 89% 奈奎斯特的平坦通带。
Enable启用反Sinc补偿高频下的Sinc衰减，第一代此功能仅在信号位于奈奎斯特区1时有效，第三代此功能在信号位于奈奎斯特区1/2时有效。</p><h2 id=插值设置interpolation-settings>插值设置(Interpolation Settings)</h2><p>插值滤波器（Interpolation Filter）将信号从低采样率上采样到高采样率，通过在输入信号中插入零值来扩展输入信号的频谱，然后对其进行低通滤波来移除扩展后信号中的高频分量。</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>OFF</td><td>滤波器被禁用，RF-DAC 不可用</td></tr><tr><td>1x</td><td>滤波器被绕过</td></tr><tr><td>2x</td><td>　2倍插值，80% Nyquist 通带</td></tr><tr><td>4x</td><td>4倍插值，80% Nyquist 通带</td></tr><tr><td>8x</td><td>8倍插值，80% Nyquist 通带</td></tr></tbody></table><p>RFdc 驱动程序 API 命令如下。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#75715e>// Get Interpolation factor for Tile0, DUC Block1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> Tile <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>u32 Block <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>u32 Interpolation_Factor;
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span>( XRFdc_GetInterpolationFactor (ptr, Tile, Block, <span style=color:#f92672>&amp;</span>Interpolation_Factor) <span style=color:#f92672>==</span> XST_SUCCESS) {
</span></span><span style=display:flex><span>	xil_printf(<span style=color:#e6db74>&#34;DAC Tile%1d,%1d Interpolation Factor is: %d&#34;</span>, Tile, Block,Interpolation_Factor);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h1 id=电源管理power-management>电源管理(Power Management)</h1><ul><li>电源模式(PowerMode):打开/关闭单个通道电源</li><li>DisableIPControl:启用/禁用RTS控制</li></ul><h1 id=混频设置mixer-settings>混频设置(Mixer Settings)</h1><p><figure><img src=../assets/images/Y2023Q1/img-155.5wcnvorhro00.jpg alt=img-155></figure>建议先设置Crossbar页面，然后设置混频器和NCO的其他参数，因为混频器在real-real模式下被旁路。</p><ul><li>模拟/数字输出(Analog/Digital Output):仅在转换器启动时可配置，可选项Real和I/Q。当转换器0设为I/Q时，转换器1也必须启用；当转换器2设为I/Q时，转换器3也必须启用。</li><li>类型(Type):可选项bypassed/coarse/fine，取决于转换器数字输出数据字段的选择。</li><li>模式(Mode):仅转换器启用时可设置，选项取决于混频器类型和数字输出数据格式，real数据对应bypassed，I/Q数据对应Real to I/Q或I/Q to I/Q。</li><li>频率(Frequency):混频器类型为coarse时可选项Fs/2，Fs/4和-Fs/4，混频器类型为fine时可选范围-10GHz到10GHz。</li><li>相位(Phase Init):仅在混频器类型为fine时可用，范围在-180到180。</li><li>刻度(Mixer Scale):无</li></ul><p>混频器RFdc API示例如下。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>XRFdc_Mixer_Settings Mixer_Settings;
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span>(tile<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;tile<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>4</span>; tile<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 确保混合器设置更新使用 Tile 事件
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span>(block<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>; block<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>2</span>; block<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        XRFdc_GetMixerSettings (ptr, XRFDC_ADC_TILE, tile, block,<span style=color:#f92672>&amp;</span>Mixer_Settings);
</span></span><span style=display:flex><span>        Mixer_Settings.EventSource <span style=color:#f92672>=</span> XRFDC_EVNT_SRC_TILE; <span style=color:#75715e>//使用XRFDC_EVNT_SRC_TILE事件更新混频器设置
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        XRFdc_SetMixerSettings (ptr, XRFDC_ADC_TILE, tile, block,<span style=color:#f92672>&amp;</span>Mixer_Settings);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>//重置 Tile0 中两个 DDC 的 NCO 相位（假设两者都处于活动状态）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    XRFdc_ResetNCOPhase(ptr, XRFDC_ADC_TILE, tile, <span style=color:#ae81ff>0</span>); <span style=color:#75715e>// DDC Block0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    XRFdc_ResetNCOPhase(ptr, XRFDC_ADC_TILE, tile, <span style=color:#ae81ff>1</span>); <span style=color:#75715e>// DDC Block1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    XRFds_UpdateEvent(ptr, XRFDC_ADC_TILE, tile, <span style=color:#ae81ff>1</span>, XRFDC_EVENT_MIXER); <span style=color:#75715e>//生成tile事件
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}  
</span></span></code></pre></div><h1 id=qmc-配置>QMC 配置</h1><p>正交调制校正(quadrature modulator correction, QMC)用于调整输出的幅度和相位，当转换器与外部调制器或解调器接口时，这些用于补偿不匹配的I和Q信号路径。<figure><img src=../assets/images/Y2023Q1/img-153.56t3vz1k4h00.jpg alt=img-153></figure></p><ul><li>增益调整(Enable Gain/Gain):将信号乘以增益因子来完成的，该因子的范围为0到2.0，可以将各个因子应用于I和Q数据路径，block输出分辨率为16位。</li><li>相位调整(Enable Phase/Phase Mismatch):通过将Q的比例分数添加到I值来实现，范围在+-26度或+-0.5数量级。这种加法的结果会导致增益误差，必须由增益误差校正块来校正，仅在复杂模式下生效。</li><li>DC偏置(Offset):直流偏移调整，仅对直流耦合有效，通过向采样信号添加一个固定的LSB值来完成的，范围是-2048到2047。</li></ul><p>可以使用RFdc驱动程序API设置增益、相位和偏移校正因子值。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#75715e>// Initial Setup
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>XRFdc_QMC_Settings QMC_Settings_I, QMC_Settings_Q; <span style=color:#75715e>// RF-ADC block0 is I, RF-ADC block1 is Q
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>QMC_Settings_I.EventSource <span style=color:#f92672>=</span> XRFDC_EVNT_SRC_TILE; <span style=color:#75715e>// QMC Settings are updated with a tile event
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>QMC_Settings_Q.EventSource <span style=color:#f92672>=</span> XRFDC_EVNT_SRC_TILE; ....
</span></span><span style=display:flex><span><span style=color:#75715e>// Update Gain/Phase/Offset for I/Q RF-DACs in tile0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>QMC_Settings_I.GainCorrectionFactor <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.9</span>; <span style=color:#75715e>// Set Gain for I
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>QMC_Settings_I.PhaseCorrectionFactor <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>5.0</span>; <span style=color:#75715e>// I/Q imbalance factor applied to I side, approx in degrees.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>QMC_Settings_I.EnableGain <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>QMC_Settings_I.EnablePhase <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>QMC_Settings_Q.GainCorrectionFactor <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.95</span>;
</span></span><span style=display:flex><span>QMC_Settings_Q.EnableGain <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>XRFdc_SetQMCSettings(ptr, XRFDC_ADC_TILE, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#f92672>&amp;</span>QMC_Settings_I); <span style=color:#75715e>// Write settings for ADC0,0 - I ADC
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>XRFdc_SetQMCSettings(ptr, XRFDC_ADC_TILE, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, <span style=color:#f92672>&amp;</span>QMC_Settings_Q); <span style=color:#75715e>//Write settings for ADC0,1 - Q ADC
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>XRFdc_UpdateEvent(ptr, XRFDC_ADC_TILE, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, XRFDC_EVENT_QMC); <span style=color:#75715e>//Generate a Tile Update Event - applies all QMC Settings at once
</span></span></span></code></pre></div><p>还可以使用<code>XRFdc_GetQMCSettings RFdc</code>驱动程序API命令从任何转换器读回QMC设置。</p><h1 id=锁相环phase-locked-loop-pll>锁相环(Phase-Locked Loop, PLL)</h1><p><figure><img src=../assets/images/Y2023Q1/img-27.58oy6tchlwo0.jpg alt=img-27></figure></p><ul><li>时钟源(Clocking Source)<ul><li>外部(External):选择时钟源来自外部，通常为几GHz量级。</li><li>板上(Onboard):选择时钟源来自板上，输入时钟一般小于1GHz。<ul><li>参考时钟(Clocking Reference)频率:可以来自外部输入或源tile转发时钟。</li><li>输入时钟 (Tile Clock Input):数值和之前时钟配置的值一致，和采样率有关，因为采样时钟是使用这个时钟经过PLL生成的。</li></ul></li></ul></li><li>内部锁相环(Internal PLL)<ul><li>Enable:是否启用内部PLL，当片中的至少一个转换器被启用时，它是可配置的。启用PLL时需确保输入频率在Zynq UltraScale+ RFSoC Data Sheet范围内，绕过PLL时转换器的采样时钟作为输入时钟。</li><li>Bypassed</li></ul></li></ul><p>IP向导或专用于配置PLL系统的API函数将参考分频器值设置为整数，将反馈分频器值设置为整数，将输出分频器值设置为整数，以达到最佳性能。PLL频率输出<code>Fs = (Fin/R)*(FBDiv/M)</code>，其中Fin是参考频率，其他参数(RF-ADC Gen 1/Gen 2/Gen 3/DFE and RF-DAC Gen 1/Gen 2)如下表。</p><table><thead><tr><th>参数</th><th>范围</th></tr></thead><tbody><tr><td>参考分频器(Reference Divider)(R)</td><td>1 to 4</td></tr><tr><td>反馈分频器(Feedback Divider)(N)</td><td>13 to 160</td></tr><tr><td>输出分频器(Output Divider)(M)</td><td>2, 3, 4 ,6, 8,&mldr; (even numbers ≤ 64)</td></tr><tr><td>压控振荡器(VCO)Frequency(GHz)</td><td>8.5 to 13.2</td></tr></tbody></table><h1 id=crossbar和多频段multi-bands>Crossbar和多频段(Multi-Bands)</h1><p><figure><img src=../assets/images/Y2023Q1/img-30.1ev1wv9ss1cw.jpg alt=img-30></figure>Crossbar页面影响混频器的real或complex模式以及multi-bands模式。complex模式激活一对信道以支持同相(I)和正交(Q)信号。由于复数混频器(和NCO)架构，允许实到复(real-to-complex,R2C)或复到复(complex-to-complex,C2C)模式，但不允许复到实(complex-to-real,C2R)模式。这意味着没有可用于RF-ADC的C2R模式和可用于RF-DAC的R2C模式。在complex模式中，偶数信道始终用于I信号，奇数信道用于Q信号。
Multi-bands允许一个DAC/ADC模拟信道能够共享多个DUC或DDC信道来发送或接收多波段载波信号。对于DAC，多个基带信号可以在单独的DUC链中进行上转换，然后在crossbar上合并再发送到模拟DAC模块。Multi-bands页面影响混频器的real或 complex模式以及multi-bands模式。RF-ADC multi-bands功能支持以下配置。</p><table><thead><tr><th>模式</th><th>说明</th></tr></thead><tbody><tr><td>Real Dual-Band</td><td>每对2x multi-band实数据，一个RF-ADC模拟输入有效，两个RF-ADC数字DDC通道均已启用。</td></tr><tr><td>I/Q Dual-Band</td><td>每对2x multi-band I/Q数据，两个RF-ADC输入有效，一个用于I，一个用于Q，两个RF-ADC数字DDC通道均已启用。</td></tr><tr><td>Real Quad-Band (Quad ADC tile only)</td><td>每个tile有4x multi-band实数据，一个RF-ADC模拟输入有效，四个RF-ADC数字DDC通道均已启用。</td></tr><tr><td>I/Q Quad-Band (Quad ADC tile only)</td><td>每个tile有4x multi-band I/Q数据，两个RF-ADC输入有效，一个用于I，一个用于Q，四个RF-ADC数字DDC通道均已启用。</td></tr></tbody></table><p>当多频段关闭时，I和Q输入直接通过多频段路由逻辑;当多频段开启时，I和Q输入被路由到tile中的多个DDC 模块。<figure><img src=https://raw.githubusercontent.com/lxulxu/MarkdownPic/master20230227/img-156.1rgyzywlxn28.jpg alt=img-156></figure>RF-ADC多频段是通过将一个RF-ADC模拟模块的输出路由到多个RF-ADC DDC模块来实现的。每个块处理一个数据带，并且可以从多个载波混合到基带。下图中的Quad ADC块显示了这一点。<figure><img src=../assets/images/Y2023Q1/img-157.62vhzzi92m00.jpg alt=img-157></figure>RF-ADC Tile 0 (Tile_224) 配置为实输入到I/Q输出模式。ADC0转换双频信号；ADC1关闭。顶部对可以配置为独立的 RF-ADC。双频输出路由到ADC0和ADC1的DDC模块。DDC模块中的混频器可以配置为从输入数据中提取正确的频带。
RF-ADC Tile 1 (Tile_225) 配置为4x多频段I/Q输入到I/Q输出模式。这里ADC0承载四波段I信号，ADC1承载Q数据。ADC2和ADC3关闭。RF-ADC的输出被路由到所有四个DDC模块。每个DDC都可以配置为从所需的频带中提取数据。</p><h1 id=fifo深度和时钟clock-distribution>FIFO深度和时钟(Clock Distribution)</h1><p><figure><img src=../assets/images/Y2023Q1/img-41.1u5d9itfn97k.jpg alt=img-41></figure></p><ul><li>Fin:输入频率</li><li>MMCM:输入时钟分频器Reference Clock经过分频后变成PLL Reference Clock，在MMCM模块中，MMCM为PL侧的FIFO生成读取或写入时钟，在FIFO数据页面中显示为F(PL)。</li><li>F(PL):MMCM为PL端的FIFO生成的读写时钟，计算公式F(PL)=Fin*M/D/ClkDiv。</li><li>时钟分频(FabClkDiv):在非MTS位流中，转换器采样时钟(Fs，也称为T1)除以8或4，然后除以FabCLKDiv。作为输入参考传输至MMCM模块。</li><li>捕获样本数(Number of Samples)</li><li>F(T1):Tile时钟</li></ul><h1 id=fft频谱分析>FFT频谱分析</h1><p>单击ADC设置页面中的Acquisition按钮或DAC设置页面中的Generation按钮，将打开FFT页面。在DAC FFT页面中，UI中自带单音和双音发生配置选项。要生成复杂的调制信号，用户可以从文件加载测试向量。Fs表示观察到的RF-ADC或RF-DAC的采样频率，Eff.Fs表示抽取后或插值前原始数据流（基带）的采样频率。FFT图的X轴（频率）反映了Eff.Fs。<figure><img src=../assets/images/Y2023Q1/img-68.6zlmduopqqc0.jpg alt=img-68></figure></p><p>传统ADC规格</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>无杂散动态范围(SFDR)</td><td>衡量数据转换器在杂散分量干扰基本信号或导致基本信号失真之前可用的动态范围,定义是基本正弦波信号均方根(RMS)值与从0Hz(DC)到二分之一数据转换器采样速率(如fs/2)范围内测得的输出峰值杂散信号均方根值之比，单位为dBc。</td></tr><tr><td>信噪比(SNR)</td><td>量化数据转换器内噪声的参数，输入信号功率与噪声功率的比值，单位为dB。</td></tr><tr><td>信噪失真比(SNDR)</td><td>单位为dBc，代表输入信号的质量，SNDR 越大，输入功率中的噪声和杂散比率越小。</td></tr><tr><td>有效位数(ENOB)</td><td>衡量数据转换器相对于输入信号在奈奎斯特带宽上的转换质量（以位为单位）。</td></tr></tbody></table><p>RF采样数据转换器规格</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>噪声频谱密度(NSD)</td><td>RF-ADC满刻度输入下每赫兹频率对应的噪声功率，一般使用 dBFS/Hz 为单位，用于衡量有独特采样率的数据转换器的噪声性能。</td></tr><tr><td>三阶交调(IM3)</td><td>任何复杂信号都同时包含多个频率分量。转换器传输函数的非线性不仅会造成单一频率失真，也会导致两个或更多信号频率相互作用，产生交调产物。</td></tr><tr><td>邻信道泄漏比(ACLR)</td><td>在通过空中接口传输信号时，从被传输信号泄漏到邻近信道的功率会干扰邻近信道中的传输，劣化无线电系统的总体性能。</td></tr></tbody></table><p>其他</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>FundA</td><td>fund 信号的 RMS 功率电平，以 dBFS 表示。</td></tr><tr><td>SFDRxH23</td><td>SFDR 不包括以 dBc 为单位的二次和三次谐波失真。谐波失真的位置是可预测的，因此可以在应用中单独处理。因此，列出了单独的 SFDRxH23 供参考。</td></tr><tr><td>Fspur</td><td>第一个奈奎斯特频带中最差 spur 的频率位置，单位为 MHz。</td></tr><tr><td>FspurxH23</td><td>最差杂散的频率位置不包括第一奈奎斯特频带中以 MHz 为单位的二次谐波和三次谐波失真。本参数包括 ADC OIS、GTIS 和 PLL 参考杂散。</td></tr><tr><td>THD</td><td>总谐波失真，单位为 dBc。THD 是 RMS 信号能量与前六次谐波之和的 RMS 值之比。</td></tr><tr><td>频率杂散</td><td>PLL 的输入参考（相位频率检测器的频率）产生的杂散，包括其谐波。当使用外部 PLL 直接计时，必须在 PLL 选项卡中指明此评估工具 GUI 的参考频率，以计算频率杂散。RF-ADC 采用交织技术构建。通过选择交织性能，偏移交织和增益/定时交织的支路列在 RF-ADC FFT 选项卡上。</td></tr><tr><td>交织偏移</td><td>偏移交织杂散的频率位置和振幅。</td></tr><tr><td>交织增益</td><td>增益/定时交织杂散的频率位置和幅度。</td></tr></tbody></table><h1 id=中断功能interrupts>中断功能(Interrupts)</h1><p>在系统异常时，自动回读一些AD/DA寄存器状态。每行开头的复选框启用或禁用(掩码)相应的中断状态。单击Apply按钮应用所选中断状态。Refresh按钮读回当前状态，绿灯显示相应的中断位被设置。Clear按钮尝试清除所有中断位并读回状态。<figure><img src=../assets/images/Y2023Q1/img-80.xcl67cmg8m8.jpg alt=img-80></figure></p><table><thead><tr><th>中断</th><th>描述</th></tr></thead><tbody><tr><td>RF-ADC/RF-DAC Datapath Interrupt</td><td>IP寄存器在0x208 0x210 0x218 0x220中断</td></tr><tr><td>Overflow in RF-DACInterpolation Stage 0/1/2/3 I or Q datapath</td><td>插值阶段溢出/饱和，Flag表示发生溢出阶段和位置。</td></tr><tr><td>Overflow in RF-ADCDecimation Stage 0/1/2/3 I or Q Datapath</td><td>RF-ADC抽取阶段溢出/饱和，Flag表示发生溢出阶段和位置。</td></tr><tr><td>Overflow in RF-DAC/RF-ADC QMC Gain/Phase</td><td>QMC增益/相位校正溢出/饱和，数据幅度或校正系数过大。</td></tr><tr><td>Overflow in RF-DAC/RF-ADC QMC Offset</td><td>QMC偏移校正溢出/饱和，数据幅度或校正系数过大。</td></tr><tr><td>Overflow in RF-DAC Inverse Sinc Filter(2nd Nyq)</td><td>RF-DAC反Sinc补偿滤波器溢出/饱和，数据过大。</td></tr><tr><td>Over/Underflow in RF-DAC Mixer</td><td>混频器溢出</td></tr><tr><td>IMR Overflow</td><td>镜像抑制模块溢出</td></tr><tr><td>Overflow in Inverse Sync Filter</td><td>混频模式中DAC反补偿模块溢出</td></tr><tr><td>Sub RF-ADC 0/1/2/3 Over/Under Range Interrupt</td><td>模拟输入超出Sub-RF-ADC范围，应减小输入信号幅度。</td></tr><tr><td>ADC Over Range</td><td>模拟输入超出RF-ADC范围，应减小输入信号幅度。要清除此中断错误，需清除sub-RF-ADC超范围中断错误。</td></tr><tr><td>ADC Over Voltage</td><td>模拟输入超出RF-ADC缓存区安全输入范围，缓存区关闭，输入信号幅度和共模电压应在范围内。</td></tr><tr><td>ADC Common Mode Over Voltage</td><td>RF-ADC输入共模电压高于指定值</td></tr><tr><td>ADC Common Mode Under Voltage</td><td>RF-ADC输入共模电压低于指定值</td></tr><tr><td>RF-ADC/RF-DAC FIFO Over/Underflow</td><td>IP寄存器中断在0x208, 0x210, 0x218, 0x220之一，要清除此中断错误，需清除所有路径的子中断错误。</td></tr><tr><td>RF-ADC/RF-DAC OverflowRF-ADC/RF-DAC UnderflowRF-ADC/RF-DAC Marginal OverflowRF-ADC/RF-DAC Marginal Underflow</td><td>FIFO接口设置不正确，时钟/数据吞入率不匹配。</td></tr></tbody></table><h1 id=多通道同步multi-tile-synchronization>多通道同步(Multi-Tile Synchronization)</h1><p>FIFO为RF-ADC提供灵活的数据和时钟接口。但与所有双时钟FIFO一样，延迟可能会在一个tile和另一个tile之间变化。虽然 tile中的所有通道都具有相同的延迟，但某些应用可能需要使用多个RF-ADC tile，并且需要在所有RF-ADC通道中匹配延迟。这些应用程序可以使用多通道同步(MTS)功能来实现这种块间同步。<figure><img src=../assets/images/Y2023Q1/img-36.317omq9p5gm0.jpg alt=img-36></figure></p><ol><li></li><li></li><li></li><li></li></ol></div></article></main><aside><div><div><h3>LATEST POSTS</h3></div><div><ul></ul></div></div></aside><footer><p>&copy; 2024 <a href=https://lxulxu.github.io/><b>lxulxu's blog</b></a>.
<a href=https://github.com/lxulxu><b>Github</b></a>.
<a href=https://space.bilibili.com/7739434><b>Bilibili</b></a>.</p></footer></body></html>