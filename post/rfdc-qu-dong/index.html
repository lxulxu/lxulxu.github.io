<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>RFdc 驱动 | lxulxu&#39;s blog</title>
<link rel="shortcut icon" href="https://lxulxu.github.io/favicon.ico?v=1702887125545">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://lxulxu.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="RFdc 驱动 | lxulxu&#39;s blog - Atom Feed" href="https://lxulxu.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="参考PG269 Appx.C
数据结构
数据结构UML图如下：

API 功能
系统设置相关函数



函数原型
功能




u32 XRFdc_CfgInitialize(XRFdc *InstancePtr, XRFdc_Config..." />
    <meta name="keywords" content="xilinx" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <!--
 * @Author: lxulxu
 * @Date: 2022-03-26 17:36:36
 * @LastEditors: lxulxu
 * @LastEditTime: 2022-08-13 13:38:08
 * @FilePath: \Helperd:\文档\Gridea\themes\notes\templates\includes\header.ejs
 * @Description: 
 * 
 * Copyright (c) 2022 by lxulxu, All Rights Reserved. 
-->
<div class="site-header">
  <a href="https://lxulxu.github.io">
  <img class="avatar" src="https://lxulxu.github.io/images/avatar.png?v=1702887125545" alt="">
  </a>
  <h1 class="site-title">
    lxulxu&#39;s blog
  </h1>
  <p class="site-description">
    Hello there
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
        <a href="https://github.com/lxulxu" target="_blank">
          <i class="ri-github-line"></i>
        </a>
      
    
      
    
      
    
      
    
      
    
      
        <a href="https://space.bilibili.com/7739434/" target="_blank">
          <i class="ri-bilibili-line"></i>
        </a>
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              RFdc 驱动
            </h2>
            <div class="post-info">
              <span>
                2023-02-21
              </span>
              <span>
                12 min read
              </span>
              
                <a href="https://lxulxu.github.io/tag/8ug-GcbTc/" class="post-tag">
                  # xilinx
                </a>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <p>参考PG269 Appx.C</p>
<h2 id="数据结构">数据结构</h2>
<p>数据结构UML图如下：</p>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/lxulxu/MarkdownPic/master/20230221/src_v1.22tzp77ow85c.jpg" alt="UML" loading="lazy"></figure>
<h2 id="api-功能">API 功能</h2>
<h3 id="系统设置相关函数">系统设置相关函数</h3>
<table>
<thead>
<tr>
<th>函数原型</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>u32 XRFdc_CfgInitialize(XRFdc *InstancePtr, XRFdc_Config *ConfigPtr)</td>
<td>通过从配置结构复制相关条目来填充驱动程序实例中的适当条目。与 RFdc 驱动程序 API 的任何软件交互都需要此函数，并且必须在使用任何其他 API 函数之前首先调用此函数。</td>
</tr>
<tr>
<td>XRFdc_Config *XRFdc_LookupConfig(u16 DeviceId)</td>
<td>根据设备的唯一 ID 查找设备配置</td>
</tr>
<tr>
<td>u32 XRFdc_RegisterMetal(XRFdc *InstancePtr, u16 DeviceId, struct metal_device **DevicePtr)</td>
<td>使用 Libmetal 注册RFDC</td>
</tr>
<tr>
<td>u32 XRFdc_StartUp(XRFdc *InstancePtr, u32 Type, int Tile_Id)</td>
<td>根据 Tile_Id 的请求重新启动片。 如果 -1 作为 Tile_Id 传递，该函数将重新启动所有启用的切片。 现有寄存器设置不会在此过程中丢失或更改。</td>
</tr>
<tr>
<td>u32 XRFdc_Shutdown(XRFdc *InstancePtr, u32 Type, int Tile_Id)</td>
<td>根据 Tile_Id 的请求停止片。 如果 -1 作为 Tile_Id 传递，该函数将停止所有启用的切片。 现有的寄存器设置不会被清除。</td>
</tr>
<tr>
<td>u32 XRFdc_Reset(XRFdc *InstancePtr, u32 Type, int Tile_Id)</td>
<td>通过 Tile_Id 请求重置图块。 如果 -1 作为 Tile_Id 传递，它将重置所有启用的图块。 所有现有的寄存器设置都将被清除并替换为最初配置的设置。</td>
</tr>
<tr>
<td>u32 XRFdc_CustomStartUp(XRFdc *InstancePtr, u32 Type, int Tile_Id, u32 StartState, u32 EndState)</td>
<td>按照通过 Tile_Id 的请求，将 IPSM 从 StartState 运行到 EndState。 如果 -1 作为 Tile_Id 传递，则该函数针对所有启用的图块运行。 如果 StartState 为 XRFDC_STATE_OFF，现有寄存器设置将丢失或更改。</td>
</tr>
<tr>
<td>void XRFdc_DumpRegs (XRFdc *InstancePtr, u32 Type, int Tile_Id)</td>
<td>用于调试，将寄存器中的内容打印到控制台。</td>
</tr>
</tbody>
</table>
<h3 id="adc-状态指示函数">ADC 状态指示函数</h3>
<table>
<thead>
<tr>
<th>函数原型</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>u32 XRFdc_Set/GetDecimationFactor(XRFdc *InstancePtr, u32 Tile_Id, u32 Block_Id, u32 *DecimationFactorPtr)</td>
<td>设置/返回 RF-ADC 抽取因子</td>
</tr>
<tr>
<td>u32 XRFdc_Set/GetDecimationFactorObs(XRFdc *InstancePtr, u32 Tile_Id, u32 Block_Id, u32 *DecimationFactorPtr)</td>
<td>设置/返回 RF-ADC 观察通道的抽取因子</td>
</tr>
<tr>
<td>u32 XRFdc_GetFabWrVldWordsObs(XRFdc *InstancePtr, u32 Type, u32 Tile_Id, u32 Block_Id, u32 *FabricWrVldWordsPtr)</td>
<td>返回 RF-ADC 观测通道的写PL数据率</td>
</tr>
<tr>
<td>u32 XRFdc_Set/GetFabRdVldWordsObs(XRFdc *InstancePtr, u32 Type, u32 Tile_Id, u32 Block_Id, u32 *FabricRdVldWordsPtr)</td>
<td>设置/返回 RF-ADC 观测通道的读PL数据率</td>
</tr>
<tr>
<td>u32 XRFdc_Set/GetThresholdSettings(XRFdc *InstancePtr, u32 Tile_Id, u32 Block_Id, XRFdc_Threshold_Settings *ThresholdSettingsPtr)</td>
<td>设置/读取相应寄存器阈值</td>
</tr>
<tr>
<td>u32 XRFdc_GetFIFOStatusObs(XRFdc *InstancePtr, u32 Type, u32 Tile_Id, u8 *EnablePtr)</td>
<td>获取 RF-ADC 观察FIFO的当前状态</td>
</tr>
<tr>
<td>u32 XRFdc_Set/GetCalibrationMode(XRFdc *InstancePtr, u32 Tile_Id, u32 Block_Id, u8 *CalibrationModePtr</td>
<td>设置/获取 RF-ADC 的校准模式</td>
</tr>
<tr>
<td>u32 XRFdc_Set/GetCalCoefficients(XRFdc *InstancePtr, u32 Tile_Id, u32 Block_Id, u32 CalibrationBlock, XRFdc_Calibration_Coefficients *CoeffPtr)</td>
<td>设置/获取通用校准系数</td>
</tr>
<tr>
<td>u32 XRFdc_Set/GetCalFreeze(XRFdc *InstancePtr, u32 Tile_Id, u32 Block_Id, XRFdc_Cal_Freeze_Settings *CalFreezePtr)</td>
<td>设置/获取通用校准冻结设置</td>
</tr>
<tr>
<td>u32 XRFdc_Set/GetDither(XRFdc *InstancePtr, u32 Tile_Id, u32 Block_Id, u32 *ModePtr)</td>
<td>用抖动模式来填充/获取所提供的指针</td>
</tr>
<tr>
<td>u32 XRFdc_GetLinkCoupling(XRFdc *InstancePtr, u32 Tile_Id, u32 Block_Id,u32 *ModePtr)</td>
<td>获取RF-ADC块的链路耦合模式</td>
</tr>
<tr>
<td>u32 XRFdc_Set/GetDSA(XRFdc *InstancePtr, u32 Tile_Id, u32 Block_Id, XRFdc_DSA_Settings *SettingsPtr)</td>
<td>传递的DSA设置被用来更新/获取相应的块级寄存器，仅适用于 RF-ADC 。</td>
</tr>
<tr>
<td>u32 XRFdc_Set/GetSignalDetector(XRFdc *InstancePtr, u32 Tile_Id, u32 Block_Id, XRFdc_Signal_Detector_Settings *SettingsPtr)</td>
<td>设置信号检测器/读取信号检测器设置，仅适用于 RF-ADC 。</td>
</tr>
<tr>
<td>u32 XRFdc_GetNoOfADCBlocks(XRFdc *InstancePtr, u32 Tile_Id)</td>
<td>获取启用的 RF-ADC 的数量</td>
</tr>
<tr>
<td>u32 XRFdc_IsADCBlockEnabled(XRFdc *InstancePtr, u32 Tile_Id, u32 Block_Id)</td>
<td>如果请求的RF-ADC被启用，函数返回1；否则返回0。</td>
</tr>
<tr>
<td>u32 XRFdc_IsHighSpeedADC(XRFdc *InstancePtr, int Tile)</td>
<td>返回该瓦片是否为高速瓦片。</td>
</tr>
<tr>
<td>u32 XRFdc_IsADCDigitalPathEnabled(XRFdc *InstancePtr, u32 Tile_Id, u32 Block_Id)</td>
<td>检查ADC数字路径是否被启用或禁用</td>
</tr>
</tbody>
</table>
<h3 id="adc-设置状态指示函数">ADC 设置状态指示函数</h3>
<table>
<thead>
<tr>
<th>函数原型</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>u32 XRFdc_ThresholdStickyClear(XRFdc *InstancePtr, u32 Tile_Id, u32 Block_Id, u32 ThresholdToUpdate)</td>
<td>清除阈值配置寄存器中的sticky位</td>
</tr>
<tr>
<td>u32 XRFdc_SetThresholdClrMode(XRFdc *InstancePtr, u32 Tile_Id, u32 Block_Id, u32 ThresholdToUpdate, u32 ClrMode)</td>
<td>设置阈值清除模式</td>
</tr>
<tr>
<td>u32 XRFdc_SetupFIFOObs(XRFdc *InstancePtr, u32 Type, int Tile_Id, u8 Enable)</td>
<td>启用和禁用RF-ADC的观察通道FIFO</td>
</tr>
<tr>
<td>u32 XRFdc_SetupFIFOBoth(XRFdc *InstancePtr, u32 Type, int Tile_Id, u8 Enable)</td>
<td>启用和禁用RF-ADC实际和观察通道的FIFO</td>
</tr>
<tr>
<td>u32 XRFdc_DisableCoefficientsOverride(XRFdc *InstancePtr, u32 Tile_Id, u32 Block_Id, u32 CalibrationBlock)</td>
<td>禁用所选块的系数覆盖</td>
</tr>
</tbody>
</table>
<h3 id="dac-状态指示函数">DAC 状态指示函数</h3>
<table>
<thead>
<tr>
<th>函数原型</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>u32 XRFdc_Set/GetInterpolationFactor(XRFdc *InstancePtr, u32 Tile_Id, u32 Block_Id, u32 *InterpolationFactorPtr)</td>
<td>设置/返回 RF-DAC 的插值因子</td>
</tr>
<tr>
<td>u32 XRFdc_Set/GetDecoderMode(XRFdc *InstancePtr, u32 Tile_Id, u32 Block_Id, u32 *DecoderModePtr)</td>
<td>从相关寄存器中设置/读取解码器模式</td>
</tr>
<tr>
<td>u32 XRFdc_GetOutputCurr(XRFdc *InstancePtr, u32 Tile_Id, u32 Block_Id, u32 *OutputCurrPtr)</td>
<td>获取输出电流</td>
</tr>
<tr>
<td>u32 XRFdc_Set/GetInvSincFIR(XRFdc *InstancePtr, u32 Tile_Id, u32 Block_Id, u16 *ModePtr)</td>
<td>设置/获取InvSinc滤波器的状态</td>
</tr>
<tr>
<td>u32 XRFdc_GetDACDataScaler(XRFdc *InstancePtr, u32 Tile_Id, u32 Block_Id, u32 *EnablePtr)</td>
<td>获取数据缩放器的启用状态</td>
</tr>
<tr>
<td>u32 XRFdc_Set/GetDACCompMode(XRFdc *InstancePtr, u32 Tile_Id, u32 Block_Id, u32 *Enable)</td>
<td>设置/返回传统的DAC输出模式</td>
</tr>
<tr>
<td>u32 XRFdc_Set/GetDataPathMode(XRFdc *InstancePtr, u32 Tile_Id, u32 Block_Id, u32 *Mode)</td>
<td>设置/返回数据路径模式</td>
</tr>
<tr>
<td>u32 XRFdc_Set/GetIMRPassMode(XRFdc *InstancePtr, u32 Tile_Id, u32 Block_Id, u32 *Mode)</td>
<td>设置/返回IMR滤波器模式</td>
</tr>
<tr>
<td>u32 XRFdc_GetNoOfDACBlock(XRFdc *InstancePtr, u32 Tile_Id)</td>
<td>返回启用的RF-DAC的数量</td>
</tr>
<tr>
<td>u32 XRFdc_IsDACBlockEnabled(XRFdc *InstancePtr, u32 Tile_Id, u32 Block_Id)</td>
<td>如果请求的RF-DAC被启用，该函数返回1；否则返回0。</td>
</tr>
<tr>
<td>u32 XRFdc_GetInverseSincFilter(XRFdc *InstancePtr, u32 Tile_Id, u32 Block_Id)</td>
<td>如果RF-DAC的反向sinc滤波器被启用，函数返回1；否则返回0。</td>
</tr>
<tr>
<td>u32 XRFdc_GetMixedMode(XRFdc *InstancePtr, u32 Tile_Id, u32 Block_Id)</td>
<td>返回RF-DAC的混频模式设置</td>
</tr>
<tr>
<td>u32 XRFdc_IsDACDigitalPathEnabled(XRFdc *InstancePtr, u32 Tile_Id, u32 Block_Id)</td>
<td>检查RF-DAC数字路径是否启用</td>
</tr>
</tbody>
</table>
<h3 id="dac-设置状态指示函数">DAC 设置状态指示函数</h3>
<table>
<thead>
<tr>
<th>函数原型</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>u32 XRFdc_SetFabWrVldWords(XRFdc *InstancePtr, u32 Tile_Id, u32 Block_Id, u32 FabricWrVldWords)</td>
<td>写入要为RF-DAC设置的结构数据速率</td>
</tr>
<tr>
<td>u32 XRFdc_SetDACVOP(XRFdc *InstancePtr, u32 Tile_Id, u32 Block_Id, u32 uACurrent)</td>
<td>VOP μA电流用于更新相应的块级寄存器</td>
</tr>
</tbody>
</table>
<h3 id="adcdac-状态指示函数">ADC/DAC 状态指示函数</h3>
<table>
<thead>
<tr>
<th>函数原型</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>u32 XRFdc_GetIPStatus(XRFdc *InstancePtr, XRFdc_IPStatus *IPStatusPtr)</td>
<td>返回 IP 状态</td>
</tr>
<tr>
<td>u32 XRFdc_GetBlockStatus(XRFdc *InstancePtr, u32 Type, u32 Tile_Id, u32 Block_Id, XRFdc_BlockStatus *BlockStatusPtr)</td>
<td>返回请求的块状态</td>
</tr>
<tr>
<td>u32 XRFdc_Set/GetMixerSettings(XRFdc *InstancePtr, u32 Type, u32 Tile_Id, u32 Block_Id, XRFdc_Mixer_Settings *MixerSettingsPtr)</td>
<td>设置/返回相应寄存器的混频器/NCO 设置</td>
</tr>
<tr>
<td>u32 XRFdc_Set/GetQMCSettings(XRFdc *InstancePtr, u32 Type, u32 Tile_Id, u32 Block_Id, XRFdc_QMC_Settings *QMCSettingsPtr)</td>
<td>设置/返回相关寄存器的 QMC 设置</td>
</tr>
<tr>
<td>u32 XRFdc_Set/GetCoarseDelaySettings(XRFdc *InstancePtr, u32 Type, u32 Tile_Id, u32 Block_Id, XRFdc_CoarseDelay_Settings *CoarseDelaySettingsPtr)</td>
<td>设置/返回相关寄存器的粗略延迟设置</td>
</tr>
<tr>
<td>u32 XRFdc_Set/GetFabClkOutDiv(XRFdc *InstancePtr, u32 Type, u32 Tile_Id, u16 *FabClkDivPtr)</td>
<td>设置/获取PL的时钟分频器</td>
</tr>
<tr>
<td>u32 XRFdc_GetFabWrVldWords(XRFdc *InstancePtr, u32 Type, u32 Tile_Id, u32 Block_Id, u32 *FabricWrVldWordsPtr)</td>
<td>返回PL写数据率</td>
</tr>
<tr>
<td>u32 XRFdc_GetFabRdVldWords(XRFdc *InstancePtr, u32 Type, u32 Tile_Id, u32 Block_Id, u32 *FabricRdVldWordsPtr)</td>
<td>返回PL读数据率</td>
</tr>
<tr>
<td>u32 XRFdc_GetFIFOStatus(XRFdc *InstancePtr, u32 Type, u32 Tile_Id, u8 *EnablePtr)</td>
<td>返回FIFO的当前状态</td>
</tr>
<tr>
<td>u32 XRFdc_Set/GetNyquistZone(XRFdc *InstancePtr, u32 Type, u32 Tile_Id, u32 Block_Id, u32 *NyquistZonePtr)</td>
<td>设置/返回奈奎斯特区</td>
</tr>
<tr>
<td>u32 XRFdc_GetClockSource(XRFdc *InstancePtr, u32 Type, u32 Tile_Id, u32 *ClockSourcePtr</td>
<td>返回时钟源</td>
</tr>
<tr>
<td>u32 XRFdc_GetPLLConfig(XRFdc *InstancePtr, u32 Type, u32 Tile_Id, XRFdc_PLL_Settings *PLLSettings)</td>
<td>从寄存器中读取PLL设置</td>
</tr>
<tr>
<td>u32 XRFdc_GetPLLLockStatus(XRFdc *InstancePtr, u32 Type, u32 Tile_Id, u32 *LockStatusPtr)</td>
<td>返回PLL锁定状态</td>
</tr>
<tr>
<td>u32 XRFdc_Set/GetClkDistribution(XRFdc *InstancePtr, XRFdc_Distribution_System_Settings *DistributionArrayPtr)</td>
<td>设置/返回时钟分布设置</td>
</tr>
<tr>
<td>u32 XRFdc_GetPwrMode(XRFdc *InstancePtr, u32 Type, u32 Tile_Id, u32 Block_Id, XRFdc_Pwr_Mode_Settings *SettingsPtr)</td>
<td>返回电源模式</td>
</tr>
<tr>
<td>u32 XRFdc_Get_TileBaseAddr(XRFdc *InstancePtr, u32 Type, u32 Tile_Id)</td>
<td>返回片的基地址</td>
</tr>
<tr>
<td>u32 XRFdc_Get_BlockBaseAddr(XRFdc *InstancePtr, u32 Type, u32 Tile_Id, u32 Block_Id）</td>
<td>返回转换器的基地址</td>
</tr>
<tr>
<td>u32 XRFdc_GetDataType(XRFdc *InstancePtr, u32 Type, u32 Tile_Id, u32 Block_Id）</td>
<td>如果数据类型为实数，函数返回0；否则，返回1。</td>
</tr>
<tr>
<td>u32 XRFdc_GetDataWidth(XRFdc *InstancePtr, u32 Type, u32 Tile_Id, u32 Block_Id)</td>
<td>返回编程数据宽度</td>
</tr>
<tr>
<td>u32 XRFdc_GetMasterTile(XRFdc *InstancePtr, u32 Type)</td>
<td>返回主瓦片ID</td>
</tr>
<tr>
<td>u32 XRFdc_GetSysRefSource(XRFdc *InstancePtr, u32 Type)</td>
<td>返回 SYSREF 的来源</td>
</tr>
<tr>
<td>u32 XRFdc_Get_IPBaseAddr(XRFdc *InstancePtr)</td>
<td>返回IP的基地址</td>
</tr>
<tr>
<td>double XRFdc_GetFabClkFreq(XRFdc *InstancePtr, u32 Type, u32 Tile_Id)</td>
<td>返回已编程的PL时钟频率</td>
</tr>
<tr>
<td>u32 XRFdc_IsFifoEnabled（XRFdc *InstancePtr, u32 Type, u32 Tile_Id, u32 Block_Id)</td>
<td>如果FIFO被启用，该函数返回1；否则，返回0。</td>
</tr>
<tr>
<td>double XRFdc_GetDriverVersion()</td>
<td>获取驱动程序的版本</td>
</tr>
<tr>
<td>int XRFdc_GetConnectedIData(XRFdc *InstancePtr, u32 Type, u32 Tile_Id, u32 Block_Id)</td>
<td>获取I数字数据路径的转换器</td>
</tr>
<tr>
<td>int XRFdc_GetConnectedQData(XRFdc *InstancePtr, u32 Type, u32 Tile_Id, u32 Block_Id)</td>
<td>获取Q数字数据路径连接的转换器</td>
</tr>
<tr>
<td>u16 XRFdc_RDReg(XRFdc *InstancePtr, u32 BaseAddr, u32 RegAddr, u16 Mask)</td>
<td>对值进行读取和屏蔽</td>
</tr>
<tr>
<td>u32 XRFdc_CheckDigitalPathEnabled(XRFdc *InstancePtr, u32 Type, u32 Tile_Id, u32 Block_Id)</td>
<td>检查数字路径是否被激活</td>
</tr>
<tr>
<td>u32 XRFdc_GetMultibandConfig(XRFdc *InstancePtr, u32 Type, u32 Tile_Id)</td>
<td>获取多频段配置数据</td>
</tr>
<tr>
<td>u32 XRFdc_CheckBlockEnabled(XRFdc *InstancePtr, u32 Type, u32 Tile_Id, u32 Block_Id)</td>
<td>检查RF-ADC/RF-DAC块是否被激活或禁用</td>
</tr>
<tr>
<td>u32 XRFdc_CheckTileEnabled(XRFdc *InstancePtr, u32 Type, u32 Tile_Id)</td>
<td>检查RF-ADC/RF-DAC瓦片是否被启用或禁用</td>
</tr>
<tr>
<td>u32 XRFdc_GetMaxSampleRate(XRFdc *InstancePtr, u32 Type, u32 Tile_Id, double *MaxSampleRatePtr)</td>
<td>获取瓦片的最大采样率</td>
</tr>
<tr>
<td>u32 XRFdc_GetMinSampleRate(XRFdc *InstancePtr, u32 Type, u32 Tile_Id, double *MinSampleRatePtr)</td>
<td>获取瓦片的最小采样率</td>
</tr>
</tbody>
</table>
<h3 id="adcdac-设置状态指示函数">ADC/DAC 设置状态指示函数</h3>
<table>
<thead>
<tr>
<th>函数原型</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>u32 XRFdc_UpdateEvent(XRFdc *InstancePtr, u32 Type, u32 Tile_Id, u32 Block_Id, u32 Event)</td>
<td>当事件源为 Slice 或 Tile 时，使用该函数触发事件的更新事件。</td>
</tr>
<tr>
<td>u32 XRFdc_ResetNCOPhase(XRFdc *InstancePtr, u32 Type, u32 Tile_Id, u32 Block_Id)</td>
<td>启动当前块相位累加器的NCO相位复位</td>
</tr>
<tr>
<td>u32 XRFdc_SetupFIFO(XRFdc *InstancePtr, u32 Type, int Tile_Id, u8 Enable)</td>
<td>启用和禁用RF-ADC/RF-DAC的FIFO</td>
</tr>
<tr>
<td>u32 XRFdc_MultiBand(XRFdc *InstancePtr, u32 Type, u32 Tile_Id, u8 DigitalDataPathMask, u32 DataType, u32 DataConverterMask)</td>
<td>设置单频和多频配置</td>
</tr>
<tr>
<td>void XRFdc_MultiConverter_Init(XRFdc_MultiConverter_Sync_Config *ConfigPtr, int *PLL_CodesPtr, int *T1_CodesPtr, u32 RefTile)</td>
<td>初始化多轨同步配置结构，必须在XRFdc_MultiConverter_Sync之前调用。</td>
</tr>
<tr>
<td>u32 XRFdc_MultiConverter_Sync(XRFdc *InstancePtr, u32 Type, XRFdc_MultiConverter_Sync_Config *ConfigPtr)</td>
<td>多片同步</td>
</tr>
<tr>
<td>u32 XRFdc_DynamicPLLConfig(XRFdc *InstancePtr, u32 Type, u32 Tile_Id, u8 Source, double RefClkFreq, double SamplingRate)</td>
<td>用于在内部PLL和外部时钟源之间的动态切换，以及为RF-ADC/RF-DAC配置内部PLL。</td>
</tr>
<tr>
<td>u32 XRFdc_MTS_Sysref_Config(XRFdc *InstancePtr, XRFdc_MultiConverter_Sync_Config *DACSyncConfigPtr, XRFdc_MultiConverter_Sync_Config *ADCSyncConfigPtr, u32 SysRefEnable)</td>
<td>启用和禁用sysref</td>
</tr>
<tr>
<td>u32 XRFdc_ResetInternalFIFOWidth(XRFdc *InstancePtr, u32 Type, u32 Tile_Id,u32 Block_Id)</td>
<td>重置内部FIFO宽度，以符合RF-ADC/RF-DAC的速率变化和混频器设置。</td>
</tr>
<tr>
<td>u32 XRFdc_SetPwrMode(XRFdc *InstancePtr, u32 Type, u32 Tile_Id, u32 Block_Id, XRFdc_Pwr_Mode_Settings *SettingsPtr)</td>
<td>设置电源模式</td>
</tr>
<tr>
<td>void XRFdc_ClrSetReg(XRFdc *InstancePtr, u32 BaseAddr, u32 RegAddr, u16 Mask, u16 Data)</td>
<td>修改写入</td>
</tr>
<tr>
<td>void XRFdc_ClrReg(XRFdc *InstancePtr, u32 BaseAddr, u32 RegAddr, u16 Mask)</td>
<td>读取和清除</td>
</tr>
<tr>
<td>void XRFdc_SetConnectedIQData(XRFdc *InstancePtr, u32 Type, u32 Tile_Id, u32 Block_Id, int ConnectedIData, int ConnectedQData)</td>
<td>设置数字数据路径I和Q的连接数据转换器</td>
</tr>
</tbody>
</table>
<h2 id="中断部分">中断部分</h2>
<table>
<thead>
<tr>
<th>函数原型</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>u32 XRFdc_IntrEnable(XRFdc *InstancePtr, u32 Type, u32 Tile_Id, u32 Block_Id, u32 IntrMask）</td>
<td>通过将IntrMask作为输入并写入相应的寄存器位来启用相应转换器的中断</td>
</tr>
<tr>
<td>u32 XRFdc_IntrDisable(XRFdc *InstancePtr, u32 Type, u32 Tile_Id, u32 Block_Id, u32 IntrMask)</td>
<td>禁用中断</td>
</tr>
<tr>
<td>void XRFdc_SetStatusHandler(XRFdc *InstancePtr, void *CallBackRefPtr, XRFdc_StatusHandler FunctionPtr)</td>
<td>设置状态回调函数，当驱动程序遇到必须报告给上层软件的情况时，会调用这个函数。</td>
</tr>
<tr>
<td>u32 XRFdc_IntrClr(XRFdc *InstancePtr, u32 Type, u32 Tile_Id, u32 Block_Id, u32 IntrMask)</td>
<td>清除中断</td>
</tr>
<tr>
<td>u32 XRFdc_GetIntrStatus(XRFdc *InstancePtr, u32 Type, u32 Tile_Id, u32 Block_Id, u32 *IntrStsPtr)</td>
<td>返回中断状态</td>
</tr>
<tr>
<td>u32 XRFdc_IntrHandler(u32 Vector, void *XRFdcPtr)</td>
<td>清除中断源并打印中断原因</td>
</tr>
<tr>
<td>u32 XRFdc_GetEnabledInterrupts(XRFdc *InstancePtr, u32 Type, u32 Tile_Id, u32 Block_Id, u32 *IntrMask)</td>
<td>启用的中断来填充IntrMask</td>
</tr>
</tbody>
</table>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">数据结构</a></li>
<li><a href="#api-%E5%8A%9F%E8%83%BD">API 功能</a>
<ul>
<li><a href="#%E7%B3%BB%E7%BB%9F%E8%AE%BE%E7%BD%AE%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0">系统设置相关函数</a></li>
<li><a href="#adc-%E7%8A%B6%E6%80%81%E6%8C%87%E7%A4%BA%E5%87%BD%E6%95%B0">ADC 状态指示函数</a></li>
<li><a href="#adc-%E8%AE%BE%E7%BD%AE%E7%8A%B6%E6%80%81%E6%8C%87%E7%A4%BA%E5%87%BD%E6%95%B0">ADC 设置状态指示函数</a></li>
<li><a href="#dac-%E7%8A%B6%E6%80%81%E6%8C%87%E7%A4%BA%E5%87%BD%E6%95%B0">DAC 状态指示函数</a></li>
<li><a href="#dac-%E8%AE%BE%E7%BD%AE%E7%8A%B6%E6%80%81%E6%8C%87%E7%A4%BA%E5%87%BD%E6%95%B0">DAC 设置状态指示函数</a></li>
<li><a href="#adcdac-%E7%8A%B6%E6%80%81%E6%8C%87%E7%A4%BA%E5%87%BD%E6%95%B0">ADC/DAC 状态指示函数</a></li>
<li><a href="#adcdac-%E8%AE%BE%E7%BD%AE%E7%8A%B6%E6%80%81%E6%8C%87%E7%A4%BA%E5%87%BD%E6%95%B0">ADC/DAC 设置状态指示函数</a></li>
</ul>
</li>
<li><a href="#%E4%B8%AD%E6%96%AD%E9%83%A8%E5%88%86">中断部分</a></li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://lxulxu.github.io/post/lesslessgao-zhi-liang-cbian-cheng-zhi-nan-greatergreater-bi-ji/">
              <h3 class="post-title">
                《高质量C++编程指南》笔记
              </h3>
            </a>
          </div>
        

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '18f52d4adb1e8df55124',
    clientSecret: '7cd75fdb4ea3a192964816547ed498ad6784e04d',
    repo: 'lxulxu.github.io',
    owner: 'lxulxu',
    admin: ['lxulxu'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

        <div class="site-footer">
  Powered by <a href="https://github.com/lxulxu/lxulxu.github.io" target="_blank"> lxulxu </a>
  <a class="rss" href="https://lxulxu.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
