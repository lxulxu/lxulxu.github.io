<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on lxulxu's blog</title><link>https://lxulxu.github.io/posts/</link><description>Recent content in Posts on lxulxu's blog</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Sat, 13 Jul 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://lxulxu.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Y2024Q3 影视音总结</title><link>https://lxulxu.github.io/posts/y2024q3-media-summary/</link><pubDate>Sat, 13 Jul 2024 00:00:00 +0000</pubDate><guid>https://lxulxu.github.io/posts/y2024q3-media-summary/</guid><description>🎬MOVIES 2024-07-01. 孤战迷城 - rating: ★★★☆☆ 2024-07-06. 泳者之心 - rating: ★★★★☆ 2024-07-06. 扫黑·决不放弃 - rating: ★★★☆☆ 2024-07-09. 默杀 - rating: ★★★☆☆ 2024-07-12. 神偷奶爸4 - rating: ★★★☆☆ 2024-07-12. 落凡尘 - rating: ★★★★☆ 2024-07-13. 抓娃娃 - rating: ★★★★☆ 🎵MUSIC 2024-07-04. Lights Out - by SUNMI, BE&amp;rsquo;O from the album &amp;lsquo;[BILLION MUSIC PROJECT VOL.1]&amp;rsquo; 2024-07-11. 猜（电影《热辣滚烫》热辣心动曲） - by 希林娜依•高 from the album &amp;lsquo;猜（电影《热辣滚烫》热辣心动曲）&amp;rsquo; 2024-07-11. 藏星（电影《热辣滚烫》热辣绽放曲） - by Silence Wang from the album &amp;lsquo;藏星（电影《热辣滚烫》热辣绽放曲）&amp;rsquo; 2024-07-11.</description></item><item><title>C++中的push_back与emplace_back</title><link>https://lxulxu.github.io/posts/push_back_emplace_back/</link><pubDate>Fri, 05 Jul 2024 00:00:00 +0000</pubDate><guid>https://lxulxu.github.io/posts/push_back_emplace_back/</guid><description>1. 引言
C++标准库提供了push_back和emplace_back两种向容器末尾添加元素的方法。本文将深入分析这两个函数的区别、使用场景，以及在实际应用中的性能考虑。
2. 基本概念
2.1 push_back push_back有两个重载版本：
1void push_back(const T&amp;amp; value); 2void push_back(T&amp;amp;&amp;amp; value); 第一个版本复制元素，第二个版本移动元素。
2.2 emplace_back emplace_back是C++11引入的变参模板函数：
1template &amp;lt;class... Args&amp;gt; 2void emplace_back(Args&amp;amp;&amp;amp;... args); 它直接在容器中构造对象，参数被完美转发给元素的构造函数。
3. 主要区别
构造方式：push_back需要预先构造的对象，emplace_back在容器内构造对象。 参数传递：push_back接受对象，emplace_back接受构造函数参数。 效率：emplace_back可能避免不必要的临时对象创建和复制/移动操作。 灵活性：emplace_back可直接传递构造函数参数。 编译复杂度：emplace_back作为变参模板可能增加编译时间和内存使用。 4. 使用示例
4.1 简单类型
1std::vector&amp;lt;int&amp;gt; vec; 2vec.push_back(10); // push_back 足够简单高效 4.2 复杂对象构造
1std::vector&amp;lt;std::pair&amp;lt;int, std::string&amp;gt;&amp;gt; vec; 2// 使用 push_back 3vec.push_back(std::make_pair(1, &amp;#34;one&amp;#34;)); 4// 使用 emplace_back 5vec.emplace_back(1, &amp;#34;one&amp;#34;); // 更简洁，直接传递构造函数参数 4.3 不可移动类型
1std::vector&amp;lt;std::mutex&amp;gt; mutexes; 2mutexes.emplace_back(); // 可以工作，直接在容器中构造 mutex 3// mutexes.push_back(std::mutex()); // 编译错误，mutex 不可复制或移动 5.</description></item><item><title>Y2024Q2 影视音总结</title><link>https://lxulxu.github.io/posts/y2024q2-media-summary/</link><pubDate>Sun, 30 Jun 2024 00:00:00 +0000</pubDate><guid>https://lxulxu.github.io/posts/y2024q2-media-summary/</guid><description>🎬MOVIES 2024-04-03. 又见逍遥 - rating: ★★☆☆☆ 2024-04-03. 草木人间 - rating: ★★★★☆ 2024-04-17. 追风者 - rating: ★★★★☆ 2024-04-19. 年少日记 - rating: ★★★★★ 2024-04-23. 城中之城 - rating: ★★★★☆ 2024-04-29. 哈尔滨一九四四 - rating: ★★★☆☆ 2024-05-01. 宝贝老板 - rating: ★★★★☆ 2024-05-02. 没有一顿火锅解决不了的事 - rating: ★★★☆☆ 2024-05-02. 九龙城寨之围城 - rating: ★★★★☆ 2024-05-02. 维和防暴队 - rating: ★★★☆☆ 2024-05-02. 对你的想象 - rating: ★★★☆☆ 2024-05-03. 新上海滩 - rating: ★★★★☆ 2024-05-04. 努尔哈赤秘史 - rating: ★★★★☆ 2024-05-04. 绝对计划 - rating: ★★★★★ 2024-05-07.</description></item><item><title>C++安全指南</title><link>https://lxulxu.github.io/posts/cplusplus_security_guide/</link><pubDate>Sun, 28 Apr 2024 08:20:35 +0000</pubDate><guid>https://lxulxu.github.io/posts/cplusplus_security_guide/</guid><description>编程习惯 switch中应有default 不应在debug或错误信息中提供过多内容 不应该在客户端代码中硬编码对称加密秘钥 1 // Bad 2 char g_aes_key[] = {...}; 3 void Foo() { 4 .... 5 AES_func(g_aes_key, input_data, output_data); 6 } 1 // Good 2 char* g_aes_key; 3 void Foo() { 4 .... 5 AES_encrypt(g_aes_key, input_data, output_data); 6 } 7 void Init() { 8 g_aes_key = get_key_from_https(user_id, ...); 9 } 函数不可以返回栈上的变量的地址，而应当使用堆来传递非简单类型变量，强烈建议返回 string、vector 等类型。 1 // Bad 2 char* Foo(char* sz, int len){ 3 char a[300] = {0}; 4 if (len &amp;gt; 100) { 5 memcpy(a, sz, 100); 6 } 7 a[len] = &amp;#39;\0&amp;#39;; 8 return a; // WRONG 9 } 1 // Good 2 char* Foo(char* sz, int len) { 3 char* a = new char[300]; 4 if (len &amp;gt; 100) { 5 memcpy(a, sz, 100); 6 } 7 a[len] = &amp;#39;\0&amp;#39;; 8 return a; // OK 9 } 有逻辑联系的数组必须仔细检查 1 // Good 2 const int nWeekdays[] = {1, 2, 3, 4, 5, 6, 7}; 3 const char* sWeekdays[] = {&amp;#34;Mon&amp;#34;, &amp;#34;Tue&amp;#34;, &amp;#34;Wed&amp;#34;, &amp;#34;Thu&amp;#34;, &amp;#34;Fri&amp;#34;, &amp;#34;Sat&amp;#34;, &amp;#34;Sun&amp;#34;}; 4 assert(ARRAY_SIZE(nWeekdays) == ARRAY_SIZE(sWeekdays));//确保有关联的nWeekdays和sWeekdays数据统一 5 for (int x = 0; x &amp;lt; ARRAY_SIZE(sWeekdays); x++) { 6 if (strcmp(sWeekdays[x], input) == 0) { 7 return nWeekdays[x]; 8 } 9 } 在头文件、源代码、文档中列举的函数声明应当一致，不应当出现定义内容错位的情况 错误示例： foo.</description></item><item><title>Y2024Q1 影视音总结</title><link>https://lxulxu.github.io/posts/y2024q1-media-summary/</link><pubDate>Sun, 31 Mar 2024 00:00:00 +0000</pubDate><guid>https://lxulxu.github.io/posts/y2024q1-media-summary/</guid><description>🎬MOVIES 2024-03-08. 沙丘2 - rating: ★★★★★ 2024-03-11. 一年一度喜剧大赛 第二季 - rating: ★★★★☆ 2024-03-11. 洛城机密 - rating: ★★★★★ 2024-03-11. 阿盖尔：神秘特工 - rating: ★★★☆☆ 2024-03-11. 周处除三害 - rating: ★★★★☆ 2024-03-11. 戏杀 - rating: ★★★☆☆ 2024-03-11. 繁城之下 - rating: ★★★★★ 2024-03-11. 明天，我会成为谁的女友 - rating: ★★★★☆ 2024-03-11. 第二十条 - rating: ★★★★☆ 2024-03-11. 热辣滚烫 - rating: ★★★☆☆ 2024-03-11. 飞驰人生2 - rating: ★★★★☆ 2024-03-11. 黑袍纠察队 第一季 - rating: ★★★★☆ 2024-03-11. 血观音 - rating: ★★★★★ 2024-03-11. 三大队 - rating: ★★★★☆ 2024-03-11.</description></item><item><title>RF Analyzer 简介</title><link>https://lxulxu.github.io/posts/rf_analyzer_introduction/</link><pubDate>Tue, 28 Feb 2023 18:54:18 +0000</pubDate><guid>https://lxulxu.github.io/posts/rf_analyzer_introduction/</guid><description>参考PG269 Ch1 &amp;amp; Ch2。
特点 多达16个14-bit RF-DAC Gen 1/Gen 2:4个14-bit二倍频RF-ADC tile，2/4个14-bit四倍频RF-ADC tile； Gen 3:1/2/4个14-bit二倍频RF-ADC tile，2/4个14-bit四倍频RF-ADC tile。 支持多个转换器之间的对齐(多片同步(MTS)) 支持预编程RF-DAC和RF-ADC，用户可以定义关键参数 RF-ADC和RF-DAC有多个AX14-Stream数据接口 单独的AX14-Lite配置接口 Gen 1/Gen 2:1x(旁路)，2x, 4x, 8x抽取和插值 Gen 3:1x(旁路)，2x, 3x, 4x, 5x, 6x, 8x, 10x, 12x, 16x, 20x, 24x, 40x抽取和插值后的额外的2x插值 数字复合混频器和数控振荡器(NCO) 正交调制校正(QMC)，Gen 3每个RF-ADC有嵌入式数字步进衰减器(DSA)，每个RF-DAC有可变输出功率(VOP)控制 片上时钟系统包含每个tile的PLL Gen 3:片上时钟分配网络；TDD模式支持省电模式和RX/Obs共享模式 Dual and Quad RF-ADC/RF-DAC Tiles Tile类型 转换器数量 设备类型 说明 Quad RF-ADC 4 Gen 1/Gen 2/Gen 3/DFE 交错系数为4 Dual RF-ADC 2 Gen 1/Gen 3/DFE 交错系数为8，采样率为Quad RF-ADC两倍。 Quad RF-DAC 4 Gen 1/Gen 2/Gen 3/DFE 一个专用DUC Dual RF-DAC 2 Gen 3/DFE 两个专用DUC，Gen 3/DFE配备Quad RF-DAC或Quad/Dual RF-DAC组合，所有的tile都有外部时钟输入 下图为tile结构，虚线表示多个波段的情况。 RF-ADC/DAC RF-ADC/DAC结构如下图所示。</description></item><item><title>RF Analyzer 功能详解</title><link>https://lxulxu.github.io/posts/rf_analyzer_feature_guid/</link><pubDate>Mon, 27 Feb 2023 19:06:33 +0000</pubDate><guid>https://lxulxu.github.io/posts/rf_analyzer_feature_guid/</guid><description>RF-ADC 转换器设置(Converter Settings) 校准模式(Calibration Mode) 校准子系统由三个主要模块组成：
时间交错偏移校准模块(OCB):校正每个子RF-ADC的DC偏移 增益校准模块(GCB):校正交错子RF-ADC之间的增益差异 时间偏移校准模块(TSCB):校正交错子RF-ADC之间的时间偏移 除了自动校准外，所有四个校准模块（OCB1、OCB2、GCB、TSCB）都可用于获取和设置用户系数。 应用程序读回校准解冻时生成的系数，并在需要时恢复它们； 这有助于在输入信号不满足校准要求时保持 RF-ADC 性能。 此功能适用于 IP 向导中的每个 RF-ADC。 启用此功能会增加 IP 的大小。
1//以下示例代码显示了 TSCB 的用户系数设置。 2 3u32 Status = XRFDC_FAILURE; 4XRFdc_Calibration_Coefficients Coeffs; 5//使用下面的样本系数 6Coeffs.Coeff0 = 146; 7Coeffs.Coeff1 = 255; 8Coeffs.Coeff2 = 255; 9Coeffs.Coeff3 = 255; 10Coeffs.Coeff4 = 113; 11Coeffs.Coeff5 = 255; 12Coeffs.Coeff6 = 255 13Coeffs.Coeff7 = 255; 14Status = XRFdc_SetCalCoeffients( RFdcInstPtr, Tile, Block, 15XRFDC_CAL_BLOCK_TSCB, &amp;amp;Coeffs); 16If (Status != XRFDC_SUCCESS) { 17 /*handle error*/ 18} 使用XRFdc_SetCalCoefficients API 恢复校准系数会自动禁用实时校准。 提供 XRFdc_DisableCoefficientsOverride API 以禁用此用户系数覆盖模式并重新启用实时校准。 禁用实时校准时，实时端口校准冻结无效。</description></item><item><title>RFdc 驱动</title><link>https://lxulxu.github.io/posts/rf_driver_manual/</link><pubDate>Tue, 21 Feb 2023 14:41:35 +0000</pubDate><guid>https://lxulxu.github.io/posts/rf_driver_manual/</guid><description>参考PG269 Appx.C
数据结构 数据结构UML图如下：
API 功能 系统设置相关函数 函数原型 功能 u32 XRFdc_CfgInitialize(XRFdc *InstancePtr, XRFdc_Config *ConfigPtr) 通过从配置结构复制相关条目来填充驱动程序实例中的适当条目。与 RFdc 驱动程序 API 的任何软件交互都需要此函数，并且必须在使用任何其他 API 函数之前首先调用此函数。 XRFdc_Config *XRFdc_LookupConfig(u16 DeviceId) 根据设备的唯一 ID 查找设备配置 u32 XRFdc_RegisterMetal(XRFdc *InstancePtr, u16 DeviceId, struct metal_device **DevicePtr) 使用 Libmetal 注册RFDC u32 XRFdc_StartUp(XRFdc *InstancePtr, u32 Type, int Tile_Id) 根据 Tile_Id 的请求重新启动片。 如果 -1 作为 Tile_Id 传递，该函数将重新启动所有启用的切片。 现有寄存器设置不会在此过程中丢失或更改。 u32 XRFdc_Shutdown(XRFdc *InstancePtr, u32 Type, int Tile_Id) 根据 Tile_Id 的请求停止片。 如果 -1 作为 Tile_Id 传递，该函数将停止所有启用的切片。 现有的寄存器设置不会被清除。 u32 XRFdc_Reset(XRFdc *InstancePtr, u32 Type, int Tile_Id) 通过 Tile_Id 请求重置图块。 如果 -1 作为 Tile_Id 传递，它将重置所有启用的图块。 所有现有的寄存器设置都将被清除并替换为最初配置的设置。 u32 XRFdc_CustomStartUp(XRFdc *InstancePtr, u32 Type, int Tile_Id, u32 StartState, u32 EndState) 按照通过 Tile_Id 的请求，将 IPSM 从 StartState 运行到 EndState。 如果 -1 作为 Tile_Id 传递，则该函数针对所有启用的图块运行。 如果 StartState 为 XRFDC_STATE_OFF，现有寄存器设置将丢失或更改。 void XRFdc_DumpRegs (XRFdc *InstancePtr, u32 Type, int Tile_Id) 用于调试，将寄存器中的内容打印到控制台。 ADC 状态指示函数 函数原型 功能 u32 XRFdc_Set/GetDecimationFactor(XRFdc *InstancePtr, u32 Tile_Id, u32 Block_Id, u32 *DecimationFactorPtr) 设置/返回 RF-ADC 抽取因子 u32 XRFdc_Set/GetDecimationFactorObs(XRFdc *InstancePtr, u32 Tile_Id, u32 Block_Id, u32 *DecimationFactorPtr) 设置/返回 RF-ADC 观察通道的抽取因子 u32 XRFdc_GetFabWrVldWordsObs(XRFdc *InstancePtr, u32 Type, u32 Tile_Id, u32 Block_Id, u32 *FabricWrVldWordsPtr) 返回 RF-ADC 观测通道的写PL数据率 u32 XRFdc_Set/GetFabRdVldWordsObs(XRFdc *InstancePtr, u32 Type, u32 Tile_Id, u32 Block_Id, u32 *FabricRdVldWordsPtr) 设置/返回 RF-ADC 观测通道的读PL数据率 u32 XRFdc_Set/GetThresholdSettings(XRFdc *InstancePtr, u32 Tile_Id, u32 Block_Id, XRFdc_Threshold_Settings *ThresholdSettingsPtr) 设置/读取相应寄存器阈值 u32 XRFdc_GetFIFOStatusObs(XRFdc *InstancePtr, u32 Type, u32 Tile_Id, u8 *EnablePtr) 获取 RF-ADC 观察FIFO的当前状态 u32 XRFdc_Set/GetCalibrationMode(XRFdc *InstancePtr, u32 Tile_Id, u32 Block_Id, u8 *CalibrationModePtr 设置/获取 RF-ADC 的校准模式 u32 XRFdc_Set/GetCalCoefficients(XRFdc *InstancePtr, u32 Tile_Id, u32 Block_Id, u32 CalibrationBlock, XRFdc_Calibration_Coefficients *CoeffPtr) 设置/获取通用校准系数 u32 XRFdc_Set/GetCalFreeze(XRFdc *InstancePtr, u32 Tile_Id, u32 Block_Id, XRFdc_Cal_Freeze_Settings *CalFreezePtr) 设置/获取通用校准冻结设置 u32 XRFdc_Set/GetDither(XRFdc *InstancePtr, u32 Tile_Id, u32 Block_Id, u32 *ModePtr) 用抖动模式来填充/获取所提供的指针 u32 XRFdc_GetLinkCoupling(XRFdc *InstancePtr, u32 Tile_Id, u32 Block_Id,u32 *ModePtr) 获取RF-ADC块的链路耦合模式 u32 XRFdc_Set/GetDSA(XRFdc *InstancePtr, u32 Tile_Id, u32 Block_Id, XRFdc_DSA_Settings *SettingsPtr) 传递的DSA设置被用来更新/获取相应的块级寄存器，仅适用于 RF-ADC 。 u32 XRFdc_Set/GetSignalDetector(XRFdc *InstancePtr, u32 Tile_Id, u32 Block_Id, XRFdc_Signal_Detector_Settings *SettingsPtr) 设置信号检测器/读取信号检测器设置，仅适用于 RF-ADC 。 u32 XRFdc_GetNoOfADCBlocks(XRFdc *InstancePtr, u32 Tile_Id) 获取启用的 RF-ADC 的数量 u32 XRFdc_IsADCBlockEnabled(XRFdc *InstancePtr, u32 Tile_Id, u32 Block_Id) 如果请求的RF-ADC被启用，函数返回1；否则返回0。 u32 XRFdc_IsHighSpeedADC(XRFdc *InstancePtr, int Tile) 返回该瓦片是否为高速瓦片。 u32 XRFdc_IsADCDigitalPathEnabled(XRFdc *InstancePtr, u32 Tile_Id, u32 Block_Id) 检查ADC数字路径是否被启用或禁用 ADC 设置状态指示函数 函数原型 功能 u32 XRFdc_ThresholdStickyClear(XRFdc *InstancePtr, u32 Tile_Id, u32 Block_Id, u32 ThresholdToUpdate) 清除阈值配置寄存器中的sticky位 u32 XRFdc_SetThresholdClrMode(XRFdc *InstancePtr, u32 Tile_Id, u32 Block_Id, u32 ThresholdToUpdate, u32 ClrMode) 设置阈值清除模式 u32 XRFdc_SetupFIFOObs(XRFdc *InstancePtr, u32 Type, int Tile_Id, u8 Enable) 启用和禁用RF-ADC的观察通道FIFO u32 XRFdc_SetupFIFOBoth(XRFdc *InstancePtr, u32 Type, int Tile_Id, u8 Enable) 启用和禁用RF-ADC实际和观察通道的FIFO u32 XRFdc_DisableCoefficientsOverride(XRFdc *InstancePtr, u32 Tile_Id, u32 Block_Id, u32 CalibrationBlock) 禁用所选块的系数覆盖 DAC 状态指示函数 函数原型 功能 u32 XRFdc_Set/GetInterpolationFactor(XRFdc *InstancePtr, u32 Tile_Id, u32 Block_Id, u32 *InterpolationFactorPtr) 设置/返回 RF-DAC 的插值因子 u32 XRFdc_Set/GetDecoderMode(XRFdc *InstancePtr, u32 Tile_Id, u32 Block_Id, u32 *DecoderModePtr) 从相关寄存器中设置/读取解码器模式 u32 XRFdc_GetOutputCurr(XRFdc *InstancePtr, u32 Tile_Id, u32 Block_Id, u32 *OutputCurrPtr) 获取输出电流 u32 XRFdc_Set/GetInvSincFIR(XRFdc *InstancePtr, u32 Tile_Id, u32 Block_Id, u16 *ModePtr) 设置/获取InvSinc滤波器的状态 u32 XRFdc_GetDACDataScaler(XRFdc *InstancePtr, u32 Tile_Id, u32 Block_Id, u32 *EnablePtr) 获取数据缩放器的启用状态 u32 XRFdc_Set/GetDACCompMode(XRFdc *InstancePtr, u32 Tile_Id, u32 Block_Id, u32 *Enable) 设置/返回传统的DAC输出模式 u32 XRFdc_Set/GetDataPathMode(XRFdc *InstancePtr, u32 Tile_Id, u32 Block_Id, u32 *Mode) 设置/返回数据路径模式 u32 XRFdc_Set/GetIMRPassMode(XRFdc *InstancePtr, u32 Tile_Id, u32 Block_Id, u32 *Mode) 设置/返回IMR滤波器模式 u32 XRFdc_GetNoOfDACBlock(XRFdc *InstancePtr, u32 Tile_Id) 返回启用的RF-DAC的数量 u32 XRFdc_IsDACBlockEnabled(XRFdc *InstancePtr, u32 Tile_Id, u32 Block_Id) 如果请求的RF-DAC被启用，该函数返回1；否则返回0。 u32 XRFdc_GetInverseSincFilter(XRFdc *InstancePtr, u32 Tile_Id, u32 Block_Id) 如果RF-DAC的反向sinc滤波器被启用，函数返回1；否则返回0。 u32 XRFdc_GetMixedMode(XRFdc *InstancePtr, u32 Tile_Id, u32 Block_Id) 返回RF-DAC的混频模式设置 u32 XRFdc_IsDACDigitalPathEnabled(XRFdc *InstancePtr, u32 Tile_Id, u32 Block_Id) 检查RF-DAC数字路径是否启用 DAC 设置状态指示函数 函数原型 功能 u32 XRFdc_SetFabWrVldWords(XRFdc *InstancePtr, u32 Tile_Id, u32 Block_Id, u32 FabricWrVldWords) 写入要为RF-DAC设置的结构数据速率 u32 XRFdc_SetDACVOP(XRFdc *InstancePtr, u32 Tile_Id, u32 Block_Id, u32 uACurrent) VOP μA电流用于更新相应的块级寄存器 ADC/DAC 状态指示函数 函数原型 功能 u32 XRFdc_GetIPStatus(XRFdc *InstancePtr, XRFdc_IPStatus *IPStatusPtr) 返回 IP 状态 u32 XRFdc_GetBlockStatus(XRFdc *InstancePtr, u32 Type, u32 Tile_Id, u32 Block_Id, XRFdc_BlockStatus *BlockStatusPtr) 返回请求的块状态 u32 XRFdc_Set/GetMixerSettings(XRFdc *InstancePtr, u32 Type, u32 Tile_Id, u32 Block_Id, XRFdc_Mixer_Settings *MixerSettingsPtr) 设置/返回相应寄存器的混频器/NCO 设置 u32 XRFdc_Set/GetQMCSettings(XRFdc *InstancePtr, u32 Type, u32 Tile_Id, u32 Block_Id, XRFdc_QMC_Settings *QMCSettingsPtr) 设置/返回相关寄存器的 QMC 设置 u32 XRFdc_Set/GetCoarseDelaySettings(XRFdc *InstancePtr, u32 Type, u32 Tile_Id, u32 Block_Id, XRFdc_CoarseDelay_Settings *CoarseDelaySettingsPtr) 设置/返回相关寄存器的粗略延迟设置 u32 XRFdc_Set/GetFabClkOutDiv(XRFdc *InstancePtr, u32 Type, u32 Tile_Id, u16 *FabClkDivPtr) 设置/获取PL的时钟分频器 u32 XRFdc_GetFabWrVldWords(XRFdc *InstancePtr, u32 Type, u32 Tile_Id, u32 Block_Id, u32 *FabricWrVldWordsPtr) 返回PL写数据率 u32 XRFdc_GetFabRdVldWords(XRFdc *InstancePtr, u32 Type, u32 Tile_Id, u32 Block_Id, u32 *FabricRdVldWordsPtr) 返回PL读数据率 u32 XRFdc_GetFIFOStatus(XRFdc *InstancePtr, u32 Type, u32 Tile_Id, u8 *EnablePtr) 返回FIFO的当前状态 u32 XRFdc_Set/GetNyquistZone(XRFdc *InstancePtr, u32 Type, u32 Tile_Id, u32 Block_Id, u32 *NyquistZonePtr) 设置/返回奈奎斯特区 u32 XRFdc_GetClockSource(XRFdc *InstancePtr, u32 Type, u32 Tile_Id, u32 *ClockSourcePtr 返回时钟源 u32 XRFdc_GetPLLConfig(XRFdc *InstancePtr, u32 Type, u32 Tile_Id, XRFdc_PLL_Settings *PLLSettings) 从寄存器中读取PLL设置 u32 XRFdc_GetPLLLockStatus(XRFdc *InstancePtr, u32 Type, u32 Tile_Id, u32 *LockStatusPtr) 返回PLL锁定状态 u32 XRFdc_Set/GetClkDistribution(XRFdc *InstancePtr, XRFdc_Distribution_System_Settings *DistributionArrayPtr) 设置/返回时钟分布设置 u32 XRFdc_GetPwrMode(XRFdc *InstancePtr, u32 Type, u32 Tile_Id, u32 Block_Id, XRFdc_Pwr_Mode_Settings *SettingsPtr) 返回电源模式 u32 XRFdc_Get_TileBaseAddr(XRFdc *InstancePtr, u32 Type, u32 Tile_Id) 返回片的基地址 u32 XRFdc_Get_BlockBaseAddr(XRFdc *InstancePtr, u32 Type, u32 Tile_Id, u32 Block_Id） 返回转换器的基地址 u32 XRFdc_GetDataType(XRFdc *InstancePtr, u32 Type, u32 Tile_Id, u32 Block_Id） 如果数据类型为实数，函数返回0；否则，返回1。 u32 XRFdc_GetDataWidth(XRFdc *InstancePtr, u32 Type, u32 Tile_Id, u32 Block_Id) 返回编程数据宽度 u32 XRFdc_GetMasterTile(XRFdc *InstancePtr, u32 Type) 返回主瓦片ID u32 XRFdc_GetSysRefSource(XRFdc *InstancePtr, u32 Type) 返回 SYSREF 的来源 u32 XRFdc_Get_IPBaseAddr(XRFdc *InstancePtr) 返回IP的基地址 double XRFdc_GetFabClkFreq(XRFdc *InstancePtr, u32 Type, u32 Tile_Id) 返回已编程的PL时钟频率 u32 XRFdc_IsFifoEnabled（XRFdc *InstancePtr, u32 Type, u32 Tile_Id, u32 Block_Id) 如果FIFO被启用，该函数返回1；否则，返回0。 double XRFdc_GetDriverVersion() 获取驱动程序的版本 int XRFdc_GetConnectedIData(XRFdc *InstancePtr, u32 Type, u32 Tile_Id, u32 Block_Id) 获取I数字数据路径的转换器 int XRFdc_GetConnectedQData(XRFdc *InstancePtr, u32 Type, u32 Tile_Id, u32 Block_Id) 获取Q数字数据路径连接的转换器 u16 XRFdc_RDReg(XRFdc *InstancePtr, u32 BaseAddr, u32 RegAddr, u16 Mask) 对值进行读取和屏蔽 u32 XRFdc_CheckDigitalPathEnabled(XRFdc *InstancePtr, u32 Type, u32 Tile_Id, u32 Block_Id) 检查数字路径是否被激活 u32 XRFdc_GetMultibandConfig(XRFdc *InstancePtr, u32 Type, u32 Tile_Id) 获取多频段配置数据 u32 XRFdc_CheckBlockEnabled(XRFdc *InstancePtr, u32 Type, u32 Tile_Id, u32 Block_Id) 检查RF-ADC/RF-DAC块是否被激活或禁用 u32 XRFdc_CheckTileEnabled(XRFdc *InstancePtr, u32 Type, u32 Tile_Id) 检查RF-ADC/RF-DAC瓦片是否被启用或禁用 u32 XRFdc_GetMaxSampleRate(XRFdc *InstancePtr, u32 Type, u32 Tile_Id, double *MaxSampleRatePtr) 获取瓦片的最大采样率 u32 XRFdc_GetMinSampleRate(XRFdc *InstancePtr, u32 Type, u32 Tile_Id, double *MinSampleRatePtr) 获取瓦片的最小采样率 ADC/DAC 设置状态指示函数 函数原型 功能 u32 XRFdc_UpdateEvent(XRFdc *InstancePtr, u32 Type, u32 Tile_Id, u32 Block_Id, u32 Event) 当事件源为 Slice 或 Tile 时，使用该函数触发事件的更新事件。 u32 XRFdc_ResetNCOPhase(XRFdc *InstancePtr, u32 Type, u32 Tile_Id, u32 Block_Id) 启动当前块相位累加器的NCO相位复位 u32 XRFdc_SetupFIFO(XRFdc *InstancePtr, u32 Type, int Tile_Id, u8 Enable) 启用和禁用RF-ADC/RF-DAC的FIFO u32 XRFdc_MultiBand(XRFdc *InstancePtr, u32 Type, u32 Tile_Id, u8 DigitalDataPathMask, u32 DataType, u32 DataConverterMask) 设置单频和多频配置 void XRFdc_MultiConverter_Init(XRFdc_MultiConverter_Sync_Config *ConfigPtr, int *PLL_CodesPtr, int *T1_CodesPtr, u32 RefTile) 初始化多轨同步配置结构，必须在XRFdc_MultiConverter_Sync之前调用。 u32 XRFdc_MultiConverter_Sync(XRFdc *InstancePtr, u32 Type, XRFdc_MultiConverter_Sync_Config *ConfigPtr) 多片同步 u32 XRFdc_DynamicPLLConfig(XRFdc *InstancePtr, u32 Type, u32 Tile_Id, u8 Source, double RefClkFreq, double SamplingRate) 用于在内部PLL和外部时钟源之间的动态切换，以及为RF-ADC/RF-DAC配置内部PLL。 u32 XRFdc_MTS_Sysref_Config(XRFdc *InstancePtr, XRFdc_MultiConverter_Sync_Config *DACSyncConfigPtr, XRFdc_MultiConverter_Sync_Config *ADCSyncConfigPtr, u32 SysRefEnable) 启用和禁用sysref u32 XRFdc_ResetInternalFIFOWidth(XRFdc *InstancePtr, u32 Type, u32 Tile_Id,u32 Block_Id) 重置内部FIFO宽度，以符合RF-ADC/RF-DAC的速率变化和混频器设置。 u32 XRFdc_SetPwrMode(XRFdc *InstancePtr, u32 Type, u32 Tile_Id, u32 Block_Id, XRFdc_Pwr_Mode_Settings *SettingsPtr) 设置电源模式 void XRFdc_ClrSetReg(XRFdc *InstancePtr, u32 BaseAddr, u32 RegAddr, u16 Mask, u16 Data) 修改写入 void XRFdc_ClrReg(XRFdc *InstancePtr, u32 BaseAddr, u32 RegAddr, u16 Mask) 读取和清除 void XRFdc_SetConnectedIQData(XRFdc *InstancePtr, u32 Type, u32 Tile_Id, u32 Block_Id, int ConnectedIData, int ConnectedQData) 设置数字数据路径I和Q的连接数据转换器 中断部分 函数原型 功能 u32 XRFdc_IntrEnable(XRFdc *InstancePtr, u32 Type, u32 Tile_Id, u32 Block_Id, u32 IntrMask） 通过将IntrMask作为输入并写入相应的寄存器位来启用相应转换器的中断 u32 XRFdc_IntrDisable(XRFdc *InstancePtr, u32 Type, u32 Tile_Id, u32 Block_Id, u32 IntrMask) 禁用中断 void XRFdc_SetStatusHandler(XRFdc *InstancePtr, void *CallBackRefPtr, XRFdc_StatusHandler FunctionPtr) 设置状态回调函数，当驱动程序遇到必须报告给上层软件的情况时，会调用这个函数。 u32 XRFdc_IntrClr(XRFdc *InstancePtr, u32 Type, u32 Tile_Id, u32 Block_Id, u32 IntrMask) 清除中断 u32 XRFdc_GetIntrStatus(XRFdc *InstancePtr, u32 Type, u32 Tile_Id, u32 Block_Id, u32 *IntrStsPtr) 返回中断状态 u32 XRFdc_IntrHandler(u32 Vector, void *XRFdcPtr) 清除中断源并打印中断原因 u32 XRFdc_GetEnabledInterrupts(XRFdc *InstancePtr, u32 Type, u32 Tile_Id, u32 Block_Id, u32 *IntrMask) 启用的中断来填充IntrMask</description></item><item><title>《高质量C++编程指南》笔记</title><link>https://lxulxu.github.io/posts/high_quality_cpp_programming_notes/</link><pubDate>Sun, 04 Sep 2022 11:51:33 +0000</pubDate><guid>https://lxulxu.github.io/posts/high_quality_cpp_programming_notes/</guid><description>文件结构 头文件结构 1//版权和版本声明 2/* 3* Copyright (c) 2001,上海贝尔有限公司网络应用事业部 4* All rights reserved. 5* 6* 文件名称：graphics.h 7* 文件标识：见配置管理计划书 8* 摘 要：简要描述本文件的内容 9* 10* 当前版本：1.1 11* 作 者：输入作者（或修改者）名字 12* 完成日期：2001年7月20日 13* 14* 取代版本：1.0 15* 原作者 ：输入原作者（或修改者）名字 16* 完成日期：2001年5月10日 17*/ 18 19#ifndef GRAPHICS_H // 防止 graphics.h 被重复引用 20#define GRAPHICS_H 21#include &amp;lt;math.h&amp;gt; // 引用标准库的头文件 22... 23#include “myheader.h” // 引用非标准库的头文件 24... 25void Function1(...); // 全局函数声明 26... 27class Box // 类结构声明 28{ 29... 30}; 31#endif 版权和版本的声明 版权信息。 文件名称，标识符，摘要。 当前版本号，作者/修改者，完成日期。 版本历史信息。 预处理块 为了防止头文件被重复引用，应当用 ifndef/define/endif 结构产生预处理块</description></item><item><title>Tcl Cheat Sheet</title><link>https://lxulxu.github.io/posts/tcl-cheat-sheet/</link><pubDate>Tue, 30 Aug 2022 17:51:47 +0000</pubDate><guid>https://lxulxu.github.io/posts/tcl-cheat-sheet/</guid><description>基础语法 1puts &amp;#34;Hello World&amp;#34;#输出 2set x [expr 1 == 2 ? 1 : 2]#设置变量；三元运算符 3[exec ls]#调用子进程 4 5#if 6if { $x &amp;lt; 2} { ... } 7elseif { $x == 1 } { ... } 8 9#while 10while { $x &amp;lt; 2 } { 11	incr x 12} 13 14#for 15for { set i 0 } { $i &amp;lt; 5 } { incr i } { ... } 16 17#switch 18switch $x { 19	1 { .</description></item><item><title>许可管理</title><link>https://lxulxu.github.io/posts/license_management_guide/</link><pubDate>Wed, 10 Aug 2022 21:50:26 +0000</pubDate><guid>https://lxulxu.github.io/posts/license_management_guide/</guid><description>IEEE Std 1735-2014 Ch8 一些整理
简介 定义 1`protect license_proxyname=&amp;#34;acme_proxy&amp;#34; 2`protect license_attributes=&amp;#34;USER,MAC,PROXYINFO=1.2&amp;#34; 3`protect license_symmetric_key_method=&amp;#34;aes128-cbc&amp;#34; 4`protect license_public_key_method=&amp;#34;rsa&amp;#34; 5`protect license_keyowner=&amp;#34;ACME&amp;#34;, license_keyname=&amp;#34;ACME2014&amp;#34; 6`protect license_public_key 7AV6f6JyGUxBpr49EwxN7jfdUQcRqRFDN7Mto2ltk+emrRCQS+bW/Yvu8U3w9kx7g 8rCXFueY/S8lyKUExUP2Yi5C3K9WIFqF7Ov3Hm9/fEumxDzvYkGOGuGu/xv/OYIyb 9whEkaiPmVI8+7S/+8NJeOm3BiVaIH5XLcZvz7EW9bvc= proxyname：决定代理运行时所需的环境变量名称
attributes：提供给代理的可选属性，代理可根据这些属性授予或拒绝许可
symmetric key method： 工具与代理间传递信息的对称加密算法
public key method：后文密钥加密算法
keyowner &amp;amp; keyname：每个license_keyowner/license_keyname对都与一个public key和一个symmetric method对应，与之相反，每个public key/symmetric method对可以对应多个license_keyowner和license_keyname，加解密信封中的license_keyowner/license_keyname应该是唯一的
public key：用于加密symmetric key，base64编码DER格式，代理可以访问与之匹配的私钥
其中license_proxyname和public key是必要属性。
使用 license()
位于common block，基本语法：
protect control right = license(&amp;quot;feature&amp;quot;) ? &amp;quot;true_value&amp;quot;:&amp;quot;false_value&amp;quot;
e.g. protect control decrypt = license(&amp;quot;IP123&amp;quot;) ? &amp;quot;true&amp;quot; : &amp;quot;false&amp;quot;
license()可以建立与代理间的通信并发出许可请求，如果代理授予许可则返回布尔值TRUE，如果拒绝则返回布尔值FALSE。
license_string()
基本语法：
protect control right = license_string(&amp;quot;feature&amp;quot;)</description></item><item><title>星球大战万代模型</title><link>https://lxulxu.github.io/posts/bandai_models/</link><pubDate>Tue, 03 May 2022 20:20:35 +0000</pubDate><guid>https://lxulxu.github.io/posts/bandai_models/</guid><description> Yoda General Grievous C-3PO BB-8 &amp; D-O DIORAMA SET K-2SO Boba Fett Darth Vader Captain Phasma Stormtrooper Shoretrooper Shadow Stormtrooper First Order Stormtrooper Kylo Ren Mandalorian Razor Crest</description></item><item><title>Vivado加密IP</title><link>https://lxulxu.github.io/posts/vivado_encrypted_ip_guide/</link><pubDate>Sat, 26 Mar 2022 18:00:52 +0000</pubDate><guid>https://lxulxu.github.io/posts/vivado_encrypted_ip_guide/</guid><description>整理 UG1118 Ch6
权限管理 公共权限(Common Rights)：适用于所有EDA工具
特定权限(Vendor-Specific Rights)：授予开发者的特定权限（如控制Vivado Logic Analyzer探测器行为），此部分访问权限值覆盖普通权限同名值
条件权限(Conditional Rights)：IEEE-1735-2014 V2 引入，允许不同条件下指定不同访问权限
IEEE 1735 结构 定义域(Definition area)：定义支持的供应商及其访问权限
密钥定义(Encrypted Key Definition)
加密负载(Encrypted payload)：加密IP的Verilog、System Verilog、 VHDL源码
纯文本负载(Plain-text payload)：IP源码未加密部分
以一个完整密钥文件内容为例
1`pragma protect version = 2 2`pragma protect encrypt_agent = &amp;#34;XILINX&amp;#34; 3`pragma protect encrypt_agent_info = &amp;#34;Xilinx Encryption Tool 2021&amp;#34; 4`pragma protect begin_commonblock 5`pragma protect control error_handling = &amp;#34;delegated&amp;#34; 6`pragma protect control child_visibility = &amp;#34;delegated&amp;#34; 7`pragma protect control decryption = (activity==simulation)? &amp;#34;false&amp;#34; :&amp;#34;true&amp;#34; 8`pragma protect end_commonblock 9`pragma protect begin_toolblock 10`pragma protect rights_digest_method=&amp;#34;sha256&amp;#34; 11`pragma protect key_keyowner = &amp;#34;Xilinx&amp;#34;, key_keyname= &amp;#34;xilinxt_2021_01&amp;#34;, key_method = &amp;#34;rsa&amp;#34;, key_public_key 12MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEApgf7F4kYh0oSFzJBRoRb 13nsrAqn24fVbI7xdNG2t9G8pouFfwIXGGmQgYqYZDSmUu0wrrj3ulLvUnjRtmtziJ 141RDOYdyko1SuBEyGT1frzUu9xNitAXxp29hOrVPeKO6kGU81XHJCRJ7uWh7rwoyf 15HSUpreifLybt+UT5fyvHu21IxvOR6GHKWaQ4wdL7Txguuyf92XLJIZABEgmuVlPK 16/NjJjVRK3c/vMuQLvbihNapkyCiLIWNwDbo9oWXr7NSo3we8u6IlFmP5V8WcOmXZ 17/PZqp3QOkY2Jlm1yQt3O8PpU/8qzB7zcHjm3+Q+wB8yUYn/IMwN0t09l2AdBR37G 18EwIDAQAB 19`pragma protect control xilinx_configuration_visible = &amp;#34;false&amp;#34; 20`pragma protect control xilinx_enable_modification = &amp;#34;false&amp;#34; 21`pragma protect control xilinx_enable_probing = &amp;#34;false&amp;#34; 22`pragma protect control xilinx_enable_netlist_export = &amp;#34;false&amp;#34; 23`pragma protect control xilinx_enable_bitstream = &amp;#34;true&amp;#34; 24`pragma protect control decryption = (xilinx_activity==simulation)?</description></item></channel></rss>