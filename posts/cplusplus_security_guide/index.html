<!doctype html><html lang=en-us><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="IE=edge"><style type=text/css>body{font-family:monospace}</style><title>C++安全指南</title>
<link rel=stylesheet href=/css/style.css></head><body><header>===================<br>== <a href=https://lxulxu.github.io/>lxulxu's blog</a> ==<br>===================<div style=float:right>Hello there</div><br><p><nav><a href=/><b>Start</b></a>.
<a href=/posts/><b>Posts</b></a>.
<a href=/categories/><b>Categories</b></a>.
<a href=/tags/><b>Tags</b></a>.
<a href=/about/><b>About</b></a>.</nav></p></header><main><article><h1>C++安全指南</h1><b><time>28.04.2024 08:20</time></b>
<a href=/tags/c++>c++</a><div><h2 id=编程习惯>编程习惯</h2><ul><li>switch中应有default</li><li>不应在debug或错误信息中提供过多内容</li><li>不应该在客户端代码中硬编码对称加密秘钥</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>    <span style=color:#75715e>// Bad
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>char</span> g_aes_key[] <span style=color:#f92672>=</span> {...};
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>Foo</span>() {
</span></span><span style=display:flex><span>      ....
</span></span><span style=display:flex><span>      AES_func(g_aes_key, input_data, output_data);
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>    <span style=color:#75715e>// Good
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> g_aes_key;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>Foo</span>() {
</span></span><span style=display:flex><span>      ....
</span></span><span style=display:flex><span>      AES_encrypt(g_aes_key, input_data, output_data);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>Init</span>() {
</span></span><span style=display:flex><span>      g_aes_key <span style=color:#f92672>=</span> get_key_from_https(user_id, ...);
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><ul><li>函数不可以返回栈上的变量的地址，而应当使用堆来传递非简单类型变量，强烈建议返回 string、vector 等类型。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>    <span style=color:#75715e>// Bad
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> <span style=color:#a6e22e>Foo</span>(<span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> sz, <span style=color:#66d9ef>int</span> len){
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>char</span> a[<span style=color:#ae81ff>300</span>] <span style=color:#f92672>=</span> {<span style=color:#ae81ff>0</span>};
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (len <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>100</span>) {
</span></span><span style=display:flex><span>        memcpy(a, sz, <span style=color:#ae81ff>100</span>);
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>      a[len] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;\0&#39;</span>;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> a;  <span style=color:#75715e>// WRONG
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>    <span style=color:#75715e>// Good
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> <span style=color:#a6e22e>Foo</span>(<span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> sz, <span style=color:#66d9ef>int</span> len) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> a <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>char</span>[<span style=color:#ae81ff>300</span>];
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (len <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>100</span>) {
</span></span><span style=display:flex><span>            memcpy(a, sz, <span style=color:#ae81ff>100</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        a[len] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;\0&#39;</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> a;  <span style=color:#75715e>// OK
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span></code></pre></div><ul><li>有逻辑联系的数组必须仔细检查</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>    <span style=color:#75715e>// Good
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> nWeekdays[] <span style=color:#f92672>=</span> {<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>7</span>};
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> sWeekdays[] <span style=color:#f92672>=</span> {<span style=color:#e6db74>&#34;Mon&#34;</span>, <span style=color:#e6db74>&#34;Tue&#34;</span>, <span style=color:#e6db74>&#34;Wed&#34;</span>, <span style=color:#e6db74>&#34;Thu&#34;</span>, <span style=color:#e6db74>&#34;Fri&#34;</span>, <span style=color:#e6db74>&#34;Sat&#34;</span>, <span style=color:#e6db74>&#34;Sun&#34;</span>};
</span></span><span style=display:flex><span>    assert(ARRAY_SIZE(nWeekdays) <span style=color:#f92672>==</span> ARRAY_SIZE(sWeekdays));<span style=color:#75715e>//确保有关联的nWeekdays和sWeekdays数据统一
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> x <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; x <span style=color:#f92672>&lt;</span> ARRAY_SIZE(sWeekdays); x<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (strcmp(sWeekdays[x], input) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> nWeekdays[x];
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><ul><li>在头文件、源代码、文档中列举的函数声明应当一致，不应当出现定义内容错位的情况
错误示例：
foo.h</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>CalcArea</span>(<span style=color:#66d9ef>int</span> width, <span style=color:#66d9ef>int</span> height);
</span></span></code></pre></div><p>foo.cc</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>CalcArea</span>(<span style=color:#66d9ef>int</span> height, <span style=color:#66d9ef>int</span> width) {  <span style=color:#75715e>// Different from foo.h
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#66d9ef>if</span> (height <span style=color:#f92672>&gt;</span> real_height) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> height <span style=color:#f92672>*</span> width;
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><ul><li>检查复制粘贴的重复代码（相同代码通常代表错误）</li><li>左右一致的重复判断/永远为真或假的判断（通常代表错误）</li><li><strong>函数每个分支都应有返回值</strong>：开启适当级别的警告（GCC 中为 -Wreturn-type 并已包含在 -Wall 中）并设置为错误，可以在编译阶段发现这类错误。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>    <span style=color:#75715e>// Bad
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>Foo</span>(<span style=color:#66d9ef>int</span> bar) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (bar <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>100</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>10</span>;
</span></span><span style=display:flex><span>      } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (bar <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>10</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>上述例子当bar&lt;10时，其结果是未知的值。</p><ul><li>不得使用栈上未初始化的变量</li><li>不得直接使用刚分配的未初始化的内存（如realloc），在 C++ 中，再次强烈推荐用 string、vector 代替手动内存分配。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>    <span style=color:#75715e>// Bad
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> <span style=color:#a6e22e>Foo</span>() {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> a <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>char</span>[<span style=color:#ae81ff>100</span>];
</span></span><span style=display:flex><span>      a[<span style=color:#ae81ff>99</span>] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;\0&#39;</span>;
</span></span><span style=display:flex><span>      memcpy(a, <span style=color:#e6db74>&#34;char&#34;</span>, <span style=color:#ae81ff>4</span>);
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> a;
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>    <span style=color:#75715e>// Good
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> <span style=color:#a6e22e>Foo</span>() {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> a <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>char</span>[<span style=color:#ae81ff>100</span>];
</span></span><span style=display:flex><span>      memcpy(a, <span style=color:#e6db74>&#34;char&#34;</span>, <span style=color:#ae81ff>4</span>);
</span></span><span style=display:flex><span>      a[<span style=color:#ae81ff>4</span>] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;\0&#39;</span>;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> a;
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><ul><li>与内存分配相关的函数需要检查其返回值是否正确，以防导致程序崩溃或逻辑错误</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>    <span style=color:#75715e>// Bad
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>Foo</span>() {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> bar <span style=color:#f92672>=</span> mmap(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0x800000</span>, .....);
</span></span><span style=display:flex><span>      <span style=color:#f92672>*</span>(bar <span style=color:#f92672>+</span> <span style=color:#ae81ff>0x400000</span>) <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;\x88&#39;</span>; <span style=color:#75715e>// Wrong
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>    <span style=color:#75715e>// Good
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>Foo</span>() {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> bar <span style=color:#f92672>=</span> mmap(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0x800000</span>, .....);
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span>(bar <span style=color:#f92672>==</span> MAP_FAILED) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>      <span style=color:#f92672>*</span>(bar <span style=color:#f92672>+</span> <span style=color:#ae81ff>0x400000</span>) <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;\x88&#39;</span>;
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><ul><li>不要在if里面赋值</li><li>if里，非bool类型和非bool类型的按位操作可能代表代码存在错误</li></ul><h2 id=文件操作>文件操作</h2><ul><li><strong>避免路径穿越问题</strong>：在进行文件操作时，需要判断外部传入的文件名是否合法，如果文件名中包含 ../ 等特殊字符，则会造成路径穿越，导致任意文件的读写。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>Foo</span>() {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>char</span> file_path[PATH_MAX] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;/home/user/code/&#34;</span>;
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 如果传入的文件名包含../可导致路径穿越
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#75715e>// 例如&#34;../file.txt&#34;，则可以读取到上层目录的file.txt文件
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#66d9ef>char</span> name[<span style=color:#ae81ff>20</span>] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;../file.txt&#34;</span>;
</span></span><span style=display:flex><span>      memcpy(file_path <span style=color:#f92672>+</span> strlen(file_path), name, <span style=color:#66d9ef>sizeof</span>(name));
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>int</span> fd <span style=color:#f92672>=</span> open(file_path, O_RDONLY);
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (fd <span style=color:#f92672>!=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>char</span> data[<span style=color:#ae81ff>100</span>] <span style=color:#f92672>=</span> {<span style=color:#ae81ff>0</span>};
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> num <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        memset(data, <span style=color:#ae81ff>0</span>, <span style=color:#66d9ef>sizeof</span>(data));
</span></span><span style=display:flex><span>        num <span style=color:#f92672>=</span> read(fd, data, <span style=color:#66d9ef>sizeof</span>(data));
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (num <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>          write(STDOUT_FILENO, data, num);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        close(fd);
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>Foo</span>() {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>char</span> file_path[PATH_MAX] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;/home/user/code/&#34;</span>;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>char</span> name[<span style=color:#ae81ff>20</span>] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;../file.txt&#34;</span>;
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 判断传入的文件名是否非法，例如&#34;../file.txt&#34;中包含非法字符../，直接返回
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#66d9ef>if</span> (strstr(name, <span style=color:#e6db74>&#34;..&#34;</span>) <span style=color:#f92672>!=</span> NULL){
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 包含非法字符
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>      memcpy(file_path <span style=color:#f92672>+</span> strlen(file_path), name, <span style=color:#66d9ef>sizeof</span>(name));
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>int</span> fd <span style=color:#f92672>=</span> open(file_path, O_RDONLY);
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (fd <span style=color:#f92672>!=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>char</span> data[<span style=color:#ae81ff>100</span>] <span style=color:#f92672>=</span> {<span style=color:#ae81ff>0</span>};
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> num <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        memset(data, <span style=color:#ae81ff>0</span>, <span style=color:#66d9ef>sizeof</span>(data));
</span></span><span style=display:flex><span>        num <span style=color:#f92672>=</span> read(fd, data, <span style=color:#66d9ef>sizeof</span>(data));
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (num <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>          write(STDOUT_FILENO, data, num);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        close(fd);
</span></span><span style=display:flex><span>       }
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><ul><li>避免相对路径导致的安全问题（DLL、EXE劫持等问题）</li><li><strong>文件权限控制</strong>：在创建文件时，需要根据文件的敏感级别设置不同的访问权限，以防止敏感数据被其他恶意程序读取或写入。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>Foo</span>() {
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 不要设置为777权限，以防止被其他恶意程序操作
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#66d9ef>if</span> (creat(<span style=color:#e6db74>&#34;file.txt&#34;</span>, <span style=color:#ae81ff>0777</span>) <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        printf(<span style=color:#e6db74>&#34;文件创建失败！</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>      } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        printf(<span style=color:#e6db74>&#34;文件创建成功！</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><h2 id=内存操作>内存操作</h2><ul><li>防止各种越界写（向前/向后）</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>    <span style=color:#66d9ef>int</span> a[<span style=color:#ae81ff>5</span>];
</span></span><span style=display:flex><span>    a[<span style=color:#ae81ff>5</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span></code></pre></div><ul><li><strong>防止任意地址写</strong>:任意地址写会导致严重的安全隐患，可能导致代码执行。因此，在编码时必须校验写入的地址。
错误示例：</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>Write</span>(MyStruct dst_struct) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>char</span> payload[<span style=color:#ae81ff>10</span>] <span style=color:#f92672>=</span> { <span style=color:#ae81ff>0</span> };
</span></span><span style=display:flex><span>      memcpy(dst_struct.buf, payload, <span style=color:#66d9ef>sizeof</span>(payload));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>      MyStruct dst_stuct;
</span></span><span style=display:flex><span>      dst_stuct.buf <span style=color:#f92672>=</span> (<span style=color:#66d9ef>char</span><span style=color:#f92672>*</span>)user_controlled_value;
</span></span><span style=display:flex><span>      Write(dst_stuct);
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><h2 id=数字操作>数字操作</h2><ul><li>防止整数溢出</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>    <span style=color:#66d9ef>const</span> kMicLen <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 整数溢出
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>Foo</span>() {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>int</span> len <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>char</span> payload[<span style=color:#ae81ff>10</span>] <span style=color:#f92672>=</span> { <span style=color:#ae81ff>0</span> };
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>char</span> dst[<span style=color:#ae81ff>10</span>] <span style=color:#f92672>=</span> { <span style=color:#ae81ff>0</span> };
</span></span><span style=display:flex><span>      <span style=color:#75715e>// Bad, 由于len小于4字节，导致计算拷贝长度时，整数溢出
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#75715e>// len - MIC_LEN == 0xfffffffd
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      memcpy(dst, payload, len <span style=color:#f92672>-</span> kMicLen);
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>Foo</span>() {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>int</span> len <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>char</span> payload[<span style=color:#ae81ff>10</span>] <span style=color:#f92672>=</span> { <span style=color:#ae81ff>0</span> };
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>char</span> dst[<span style=color:#ae81ff>10</span>] <span style=color:#f92672>=</span> { <span style=color:#ae81ff>0</span> };
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>int</span> size <span style=color:#f92672>=</span> len <span style=color:#f92672>-</span> kMicLen;
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 拷贝前对长度进行判断
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#66d9ef>if</span> (size <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> size <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>10</span>) {
</span></span><span style=display:flex><span>        memcpy(dst, payload, size);
</span></span><span style=display:flex><span>        printf(<span style=color:#e6db74>&#34;memcpy good</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><ul><li>防止Off-By-One：在进行计算或者操作时，如果使用的最大值或最小值不正确，使得该值比正确值多1或少1，可能导致安全风险。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>    <span style=color:#66d9ef>char</span> firstname[<span style=color:#ae81ff>20</span>];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> lastname[<span style=color:#ae81ff>20</span>];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> fullname[<span style=color:#ae81ff>40</span>];
</span></span><span style=display:flex><span>    fullname[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;\0&#39;</span>;
</span></span><span style=display:flex><span>    strncat(fullname, firstname, <span style=color:#ae81ff>20</span>);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 第二次调用strncat()可能会追加另外20个字符。如果这20个字符没有终止空字符，则存在安全问题
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    strncat(fullname, lastname, <span style=color:#ae81ff>20</span>);
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>    <span style=color:#66d9ef>char</span> firstname[<span style=color:#ae81ff>20</span>];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> lastname[<span style=color:#ae81ff>20</span>];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> fullname[<span style=color:#ae81ff>40</span>];
</span></span><span style=display:flex><span>    fullname[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;\0&#39;</span>;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 当使用像strncat()函数时，必须在缓冲区的末尾为终止空字符留下一个空字节，避免off-by-one
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    strncat(fullname, firstname, <span style=color:#66d9ef>sizeof</span>(fullname) <span style=color:#f92672>-</span> strlen(fullname) <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    strncat(fullname, lastname, <span style=color:#66d9ef>sizeof</span>(fullname) <span style=color:#f92672>-</span> strlen(fullname) <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>);
</span></span></code></pre></div><ul><li>避免大小端错误</li><li>检查除以零异常</li><li>防止数字类型的错误强转</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>Foo</span>() {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>int</span> len <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> size <span style=color:#f92672>=</span> <span style=color:#ae81ff>9</span>;
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 1 &lt; 9 - 10 ? 由于运算中无符号和有符号混用，导致计算结果以无符号计算
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#66d9ef>if</span> (len <span style=color:#f92672>&lt;</span> size <span style=color:#f92672>-</span> <span style=color:#ae81ff>10</span>) {
</span></span><span style=display:flex><span>        printf(<span style=color:#e6db74>&#34;Bad</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>      } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        printf(<span style=color:#e6db74>&#34;Good</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>Foo</span>() {
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 统一两者计算类型为有符号
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#66d9ef>int</span> len <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>int</span> size <span style=color:#f92672>=</span> <span style=color:#ae81ff>9</span>;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (len <span style=color:#f92672>&lt;</span> size <span style=color:#f92672>-</span> <span style=color:#ae81ff>10</span>) {
</span></span><span style=display:flex><span>        printf(<span style=color:#e6db74>&#34;Bad</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>      } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        printf(<span style=color:#e6db74>&#34;Good</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><ul><li>比较数据大小时加上最小/最大值的校验</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>Foo</span>(<span style=color:#66d9ef>int</span> index) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>int</span> a[<span style=color:#ae81ff>30</span>] <span style=color:#f92672>=</span> {<span style=color:#ae81ff>0</span>};
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 此处index是int型，只考虑了index小于数组大小，但是并未判断是否大于0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#66d9ef>if</span> (index <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>30</span>) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 如果index为负数，则越界
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        a[index] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>Foo</span>(<span style=color:#66d9ef>int</span> index) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>int</span> a[<span style=color:#ae81ff>30</span>] <span style=color:#f92672>=</span> {<span style=color:#ae81ff>0</span>};
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 判断index的最大最小值
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#66d9ef>if</span> (index <span style=color:#f92672>&gt;=</span><span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> index <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>30</span>) {
</span></span><span style=display:flex><span>        a[index] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><h2 id=指针操作>指针操作</h2><ul><li>检查在pointer上使用sizeof：除了测试当前指针长度，否则一般不会在pointer上使用sizeof。
可能错误：</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>    size_t structure_length <span style=color:#f92672>=</span> <span style=color:#66d9ef>sizeof</span>(Foo<span style=color:#f92672>*</span>);
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>    size_t structure_length <span style=color:#f92672>=</span> <span style=color:#66d9ef>sizeof</span>(Foo);
</span></span></code></pre></div><ul><li>检查直接将数组和0比较的代码：开启足够的编译器警告（GCC 中为 -Waddress，并已包含在 -Wall 中），并设置为错误，可以在编译期间发现该问题。</li><li>不应当向指针赋予写死的地址：特殊情况需要特殊对待（比如开发硬件固件时可能需要写死），但是如果是系统驱动开发之类的，写死可能会导致后续的问题。</li><li>检查空指针</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>    <span style=color:#f92672>*</span>foo <span style=color:#f92672>=</span> <span style=color:#ae81ff>100</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>foo) {
</span></span><span style=display:flex><span>      ERROR(<span style=color:#e6db74>&#34;foobar&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>foo) {
</span></span><span style=display:flex><span>      ERROR(<span style=color:#e6db74>&#34;foobar&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#f92672>*</span>foo <span style=color:#f92672>=</span> <span style=color:#ae81ff>100</span>;
</span></span></code></pre></div><ul><li>释放完后置空指针</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>foo</span>() {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> p <span style=color:#f92672>=</span> (<span style=color:#66d9ef>char</span><span style=color:#f92672>*</span>)malloc(<span style=color:#ae81ff>100</span>);
</span></span><span style=display:flex><span>      memcpy(p, <span style=color:#e6db74>&#34;hello&#34;</span>, <span style=color:#ae81ff>6</span>);
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 此时p所指向的内存已被释放，但是p所指的地址仍然不变
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      printf(<span style=color:#e6db74>&#34;%s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, p);
</span></span><span style=display:flex><span>      free(p);
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 未设置为NULL，可能导致UAF等内存错误
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#66d9ef>if</span> (p <span style=color:#f92672>!=</span> NULL) {  <span style=color:#75715e>// 没有起到防错作用
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        printf(<span style=color:#e6db74>&#34;%s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, p); <span style=color:#75715e>// 错误使用已经释放的内存
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      }
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>foo</span>() {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> p <span style=color:#f92672>=</span> (<span style=color:#66d9ef>char</span><span style=color:#f92672>*</span>)malloc(<span style=color:#ae81ff>100</span>);
</span></span><span style=display:flex><span>      memcpy(p, <span style=color:#e6db74>&#34;hello&#34;</span>, <span style=color:#ae81ff>6</span>);
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 此时p所指向的内存已被释放，但是p所指的地址仍然不变
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      printf(<span style=color:#e6db74>&#34;%s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, p);
</span></span><span style=display:flex><span>      free(p);
</span></span><span style=display:flex><span>      <span style=color:#75715e>//释放后将指针赋值为空
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      p <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (p <span style=color:#f92672>!=</span> NULL)  { <span style=color:#75715e>// 没有起到防错作用
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        printf(<span style=color:#e6db74>&#34;%s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, p); <span style=color:#75715e>// 错误使用已经释放的内存
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      }
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><ul><li>防止错误的类型转换</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> NAME_TYPE <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> ID_TYPE <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 该类型根据 msg_type 进行区分，如果在对MessageBuffer进行操作时没有判断目标对象，则存在类型混淆
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>MessageBuffer</span> {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>int</span> msg_type;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>union</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>name;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> name_id;
</span></span><span style=display:flex><span>      };
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>Foo</span>() {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>MessageBuffer</span> buf;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> default_message <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Hello World&#34;</span>;
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 设置该消息类型为 NAME_TYPE，因此buf预期的类型为 msg_type + name
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      buf.msg_type <span style=color:#f92672>=</span> NAME_TYPE;
</span></span><span style=display:flex><span>      buf.name <span style=color:#f92672>=</span> default_message;
</span></span><span style=display:flex><span>      printf(<span style=color:#e6db74>&#34;Pointer of buf.name is %p</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, buf.name);
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 没有判断目标消息类型是否为ID_TYPE，直接修改nameID，导致类型混淆
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      buf.name_id <span style=color:#f92672>=</span> user_controlled_value;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (buf.msg_type <span style=color:#f92672>==</span> NAME_TYPE) {
</span></span><span style=display:flex><span>        printf(<span style=color:#e6db74>&#34;Pointer of buf.name is now %p</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, buf.name);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 以NAME_TYPE作为类型操作，可能导致非法内存读写
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        printf(<span style=color:#e6db74>&#34;Message: %s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, buf.name);
</span></span><span style=display:flex><span>      } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        printf(<span style=color:#e6db74>&#34;Message: Use ID %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, buf.name_id);
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>Foo</span>() {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>MessageBuffer</span> buf;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> default_message <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Hello World&#34;</span>;
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 设置该消息类型为 NAME_TYPE，因此buf预期的类型为 msg_type + name
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      buf.msg_type <span style=color:#f92672>=</span> NAME_TYPE;
</span></span><span style=display:flex><span>      buf.name <span style=color:#f92672>=</span> default_msessage;
</span></span><span style=display:flex><span>      printf(<span style=color:#e6db74>&#34;Pointer of buf.name is %p</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, buf.name);
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 判断目标消息类型是否为 ID_TYPE，不是预期类型则做对应操作
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#66d9ef>if</span> (buf.msg_type <span style=color:#f92672>==</span> ID_TYPE)
</span></span><span style=display:flex><span>        buf.name_id <span style=color:#f92672>=</span> user_controlled_value;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (buf.msg_type <span style=color:#f92672>==</span> NAME_TYPE) {
</span></span><span style=display:flex><span>        printf(<span style=color:#e6db74>&#34;Pointer of buf.name is now %p</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, buf.name);
</span></span><span style=display:flex><span>        printf(<span style=color:#e6db74>&#34;Message: %s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, buf.name);
</span></span><span style=display:flex><span>      } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        printf(<span style=color:#e6db74>&#34;Message: Use ID %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, buf.name_id);
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><ul><li>智能指针使用安全</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>    <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Foo</span> {
</span></span><span style=display:flex><span>     <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>explicit</span> Foo(<span style=color:#66d9ef>int</span> num) { data_ <span style=color:#f92672>=</span> num; };
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>Function</span>() { printf(<span style=color:#e6db74>&#34;Obj is %p, data = %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, <span style=color:#66d9ef>this</span>, data_); };
</span></span><span style=display:flex><span>     <span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>int</span> data_;
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>unique_ptr<span style=color:#f92672>&lt;</span>Foo<span style=color:#f92672>&gt;</span> fool_u_ptr <span style=color:#f92672>=</span> <span style=color:#66d9ef>nullptr</span>;
</span></span><span style=display:flex><span>    Foo<span style=color:#f92672>*</span> pfool_raw_ptr <span style=color:#f92672>=</span> <span style=color:#66d9ef>nullptr</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>Risk</span>() {
</span></span><span style=display:flex><span>      fool_u_ptr <span style=color:#f92672>=</span> make_unique<span style=color:#f92672>&lt;</span>Foo<span style=color:#f92672>&gt;</span>(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 从独占智能指针中获取原始指针,&lt;Foo&gt;(1)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      pfool_raw_ptr <span style=color:#f92672>=</span> fool_u_ptr.get();
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 调用&lt;Foo&gt;(1)的函数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      pfool_raw_ptr<span style=color:#f92672>-&gt;</span>Function();
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 独占智能指针重新赋值后会释放内存
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      fool_u_ptr <span style=color:#f92672>=</span> make_unique<span style=color:#f92672>&lt;</span>Foo<span style=color:#f92672>&gt;</span>(<span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 通过原始指针操作会导致UAF，pfool_raw_ptr指向的对象已经释放
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      pfool_raw_ptr<span style=color:#f92672>-&gt;</span>Function();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 输出：
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// Obj is 0000027943087B80, data = 1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// Obj is 0000027943087B80, data = -572662307
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>Safe</span>() {
</span></span><span style=display:flex><span>      fool_u_ptr <span style=color:#f92672>=</span> make_unique<span style=color:#f92672>&lt;</span>Foo<span style=color:#f92672>&gt;</span>(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 调用&lt;Foo&gt;(1)的函数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      fool_u_ptr<span style=color:#f92672>-&gt;</span>function();
</span></span><span style=display:flex><span>      fool_u_ptr <span style=color:#f92672>=</span> make_unique<span style=color:#f92672>&lt;</span>Foo<span style=color:#f92672>&gt;</span>(<span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 调用&lt;Foo&gt;(2)的函数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      fool_u_ptr<span style=color:#f92672>-&gt;</span>function();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 输出：
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// Obj is 000002C7BB550830, data = 1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// Obj is 000002C7BB557AF0, data = 2
</span></span></span></code></pre></div></div></article></main><aside><div><div><h3>LATEST POSTS</h3></div><div><ul><li><a href=/posts/2024q2-media-summary/>2024Q2 影视音总结</a></li><li><a href=/posts/cplusplus_security_guide/>C++安全指南</a></li><li><a href=/posts/2024q1-media-summary/>2024Q1 影视音总结</a></li><li><a href=/posts/rf_analyzer_introduction/>RF Analyzer 简介</a></li><li><a href=/posts/rf_analyzer_feature_guid/>RF Analyzer 功能详解</a></li></ul></div></div></aside><footer><p>&copy; 2024 <a href=https://lxulxu.github.io/><b>lxulxu's blog</b></a>.
<a href=https://github.com/lxulxu><b>Github</b></a>.
<a href=https://space.bilibili.com/7739434><b>Bilibili</b></a>.</p></footer></body></html>