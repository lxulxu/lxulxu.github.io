<!doctype html><html lang=en-us><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="IE=edge"><style type=text/css>body{font-family:monospace}</style><title>C++中的push_back与emplace_back</title>
<link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;700&display=swap" rel=stylesheet><link rel=stylesheet href=/css/style.css></head><body><header>===================<br>== <a href=https://lxulxu.github.io/>lxulxu's blog</a> ==<br>===================<div style=float:right>Hello there</div><br><p><nav><a href=/><b>Start</b></a>.
<a href=/posts/><b>Posts</b></a>.
<a href=/categories/><b>Categories</b></a>.
<a href=/tags/><b>Tags</b></a>.
<a href=/about/><b>About</b></a>.</nav></p></header><main><article><h1>C++中的push_back与emplace_back</h1><b><time>05.07.2024 00:00</time></b>
<a href=/tags/c++>c++</a><div><p><strong>1. 引言</strong></p><p>C++标准库提供了<code>push_back</code>和<code>emplace_back</code>两种向容器末尾添加元素的方法。本文将深入分析这两个函数的区别、使用场景，以及在实际应用中的性能考虑。</p><p><strong>2. 基本概念</strong></p><p>2.1 push_back
<code>push_back</code>有两个重载版本：</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#756d59">1</span><span><span style=color:#fabd2f>void</span> <span style=color:#fabd2f>push_back</span>(<span style=color:#fe8019>const</span> T<span style=color:#fe8019>&amp;</span> value);
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#756d59">2</span><span><span style=color:#fabd2f>void</span> <span style=color:#fabd2f>push_back</span>(T<span style=color:#fe8019>&amp;&amp;</span> value);
</span></span></code></pre></div><p>第一个版本复制元素，第二个版本移动元素。</p><p>2.2 emplace_back
<code>emplace_back</code>是C++11引入的变参模板函数：</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#756d59">1</span><span><span style=color:#fe8019>template</span> <span style=color:#fe8019>&lt;</span><span style=color:#fe8019>class</span>... Args<span style=color:#fe8019>&gt;</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#756d59">2</span><span><span style=color:#fabd2f>void</span> emplace_back(Args<span style=color:#fe8019>&amp;&amp;</span>... args);
</span></span></code></pre></div><p>它直接在容器中构造对象，参数被完美转发给元素的构造函数。</p><p><strong>3. 主要区别</strong></p><ol><li><strong>构造方式</strong>：<code>push_back</code>需要预先构造的对象，<code>emplace_back</code>在容器内构造对象。</li><li><strong>参数传递</strong>：<code>push_back</code>接受对象，<code>emplace_back</code>接受构造函数参数。</li><li><strong>效率</strong>：<code>emplace_back</code>可能避免不必要的临时对象创建和复制/移动操作。</li><li><strong>灵活性</strong>：<code>emplace_back</code>可直接传递构造函数参数。</li><li><strong>编译复杂度</strong>：<code>emplace_back</code>作为变参模板可能增加编译时间和内存使用。</li></ol><p><strong>4. 使用示例</strong></p><p>4.1 简单类型</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#756d59">1</span><span>std<span style=color:#fe8019>::</span>vector<span style=color:#fe8019>&lt;</span><span style=color:#fabd2f>int</span><span style=color:#fe8019>&gt;</span> vec;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#756d59">2</span><span>vec.push_back(<span style=color:#d3869b>10</span>);  <span style=color:#928374;font-style:italic>// push_back 足够简单高效
</span></span></span></code></pre></div><p>4.2 复杂对象构造</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#756d59">1</span><span>std<span style=color:#fe8019>::</span>vector<span style=color:#fe8019>&lt;</span>std<span style=color:#fe8019>::</span>pair<span style=color:#fe8019>&lt;</span><span style=color:#fabd2f>int</span>, std<span style=color:#fe8019>::</span>string<span style=color:#fe8019>&gt;&gt;</span> vec;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#756d59">2</span><span><span style=color:#928374;font-style:italic>// 使用 push_back
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#756d59">3</span><span><span style=color:#928374;font-style:italic></span>vec.push_back(std<span style=color:#fe8019>::</span>make_pair(<span style=color:#d3869b>1</span>, <span style=color:#b8bb26>&#34;one&#34;</span>));
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#756d59">4</span><span><span style=color:#928374;font-style:italic>// 使用 emplace_back
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#756d59">5</span><span><span style=color:#928374;font-style:italic></span>vec.emplace_back(<span style=color:#d3869b>1</span>, <span style=color:#b8bb26>&#34;one&#34;</span>);  <span style=color:#928374;font-style:italic>// 更简洁，直接传递构造函数参数
</span></span></span></code></pre></div><p>4.3 不可移动类型</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#756d59">1</span><span>std<span style=color:#fe8019>::</span>vector<span style=color:#fe8019>&lt;</span>std<span style=color:#fe8019>::</span>mutex<span style=color:#fe8019>&gt;</span> mutexes;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#756d59">2</span><span>mutexes.emplace_back();  <span style=color:#928374;font-style:italic>// 可以工作，直接在容器中构造 mutex
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#756d59">3</span><span><span style=color:#928374;font-style:italic>// mutexes.push_back(std::mutex()); // 编译错误，mutex 不可复制或移动
</span></span></span></code></pre></div><p><strong>5. 性能考虑：emplace_back并非总是更优</strong></p><p>虽然通常认为 <code>emplace_back</code> 在性能上优于 <code>push_back</code>，但实际情况可能并非如此简单。</p><p>5.1 理论上的优势</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#756d59"> 1</span><span><span style=color:#fe8019>class</span> MyClass {
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#756d59"> 2</span><span><span style=color:#fe8019>public</span><span style=color:#fe8019>:</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#756d59"> 3</span><span>    MyClass(<span style=color:#fabd2f>int</span> a, <span style=color:#fabd2f>double</span> b) <span style=color:#fe8019>:</span> x(a), y(b) {
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#756d59"> 4</span><span>        std<span style=color:#fe8019>::</span>cout <span style=color:#fe8019>&lt;&lt;</span> <span style=color:#b8bb26>&#34;MyClass constructed</span><span style=color:#b8bb26>\n</span><span style=color:#b8bb26>&#34;</span>;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#756d59"> 5</span><span>    }
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#756d59"> 6</span><span>    MyClass(<span style=color:#fe8019>const</span> MyClass<span style=color:#fe8019>&amp;</span>) {
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#756d59"> 7</span><span>        std<span style=color:#fe8019>::</span>cout <span style=color:#fe8019>&lt;&lt;</span> <span style=color:#b8bb26>&#34;MyClass copied</span><span style=color:#b8bb26>\n</span><span style=color:#b8bb26>&#34;</span>;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#756d59"> 8</span><span>    }
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#756d59"> 9</span><span>    MyClass(MyClass<span style=color:#fe8019>&amp;&amp;</span>) <span style=color:#fe8019>noexcept</span> {
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#756d59">10</span><span>        std<span style=color:#fe8019>::</span>cout <span style=color:#fe8019>&lt;&lt;</span> <span style=color:#b8bb26>&#34;MyClass moved</span><span style=color:#b8bb26>\n</span><span style=color:#b8bb26>&#34;</span>;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#756d59">11</span><span>    }
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#756d59">12</span><span><span style=color:#fe8019>private</span><span style=color:#fe8019>:</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#756d59">13</span><span>    <span style=color:#fabd2f>int</span> x;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#756d59">14</span><span>    <span style=color:#fabd2f>double</span> y;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#756d59">15</span><span>};
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#756d59">16</span><span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#756d59">17</span><span>std<span style=color:#fe8019>::</span>vector<span style=color:#fe8019>&lt;</span>MyClass<span style=color:#fe8019>&gt;</span> vec;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#756d59">18</span><span>vec.push_back(MyClass(<span style=color:#d3869b>10</span>, <span style=color:#d3869b>3.14</span>));  <span style=color:#928374;font-style:italic>// 构造 + 移动
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#756d59">19</span><span><span style=color:#928374;font-style:italic></span>vec.emplace_back(<span style=color:#d3869b>10</span>, <span style=color:#d3869b>3.14</span>);  <span style=color:#928374;font-style:italic>// 直接构造，理论上更高效
</span></span></span></code></pre></div><p>理论上，<code>emplace_back</code> 通过直接在容器内构造对象，避免了额外的移动操作，因此应该更高效。</p><p>5.2 编译器优化的影响</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#756d59">1</span><span>std<span style=color:#fe8019>::</span>vector<span style=color:#fe8019>&lt;</span>std<span style=color:#fe8019>::</span>string<span style=color:#fe8019>&gt;</span> vec;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#756d59">2</span><span>vec.push_back(std<span style=color:#fe8019>::</span>string(<span style=color:#b8bb26>&#34;Hello&#34;</span>));  <span style=color:#928374;font-style:italic>// 可能被优化，避免额外复制
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#756d59">3</span><span><span style=color:#928374;font-style:italic></span>vec.emplace_back(<span style=color:#b8bb26>&#34;World&#34;</span>);  <span style=color:#928374;font-style:italic>// 直接构造
</span></span></span></code></pre></div><p>现代编译器的优化能力可能会显著减小 <code>push_back</code> 和 <code>emplace_back</code> 之间的性能差距。</p><p>5.3 C++17及以后版本的改进</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#756d59">1</span><span><span style=color:#fe8019>struct</span> Expensive {
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#756d59">2</span><span>    Expensive() { std<span style=color:#fe8019>::</span>cout <span style=color:#fe8019>&lt;&lt;</span> <span style=color:#b8bb26>&#34;Constructed</span><span style=color:#b8bb26>\n</span><span style=color:#b8bb26>&#34;</span>; }
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#756d59">3</span><span>    Expensive(<span style=color:#fe8019>const</span> Expensive<span style=color:#fe8019>&amp;</span>) { std<span style=color:#fe8019>::</span>cout <span style=color:#fe8019>&lt;&lt;</span> <span style=color:#b8bb26>&#34;Copied</span><span style=color:#b8bb26>\n</span><span style=color:#b8bb26>&#34;</span>; }
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#756d59">4</span><span>    Expensive(Expensive<span style=color:#fe8019>&amp;&amp;</span>) <span style=color:#fe8019>noexcept</span> { std<span style=color:#fe8019>::</span>cout <span style=color:#fe8019>&lt;&lt;</span> <span style=color:#b8bb26>&#34;Moved</span><span style=color:#b8bb26>\n</span><span style=color:#b8bb26>&#34;</span>; }
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#756d59">5</span><span>};
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#756d59">6</span><span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#756d59">7</span><span>std<span style=color:#fe8019>::</span>vector<span style=color:#fe8019>&lt;</span>Expensive<span style=color:#fe8019>&gt;</span> vec;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#756d59">8</span><span>vec.push_back(Expensive());  <span style=color:#928374;font-style:italic>// C++17: 直接构造，不会调用移动构造函数
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#756d59">9</span><span><span style=color:#928374;font-style:italic></span>vec.emplace_back();          <span style=color:#928374;font-style:italic>// 直接构造
</span></span></span></code></pre></div><p>C++17引入的保证复制省略（guaranteed copy elision）进一步模糊了 <code>push_back</code> 和 <code>emplace_back</code> 之间的界限。</p><p>5.4 性能结论</p><p>尽管 <code>emplace_back</code> 在某些情况下确实可能提供性能优势，但这种优势并不像人们通常认为的那样普遍或显著。实际上，由于编译器优化和语言标准的演进，在许多常见情况下，<code>push_back</code> 和 <code>emplace_back</code> 的性能可能非常接近。</p><p><strong>6. 代码维护性</strong></p><p>在追求性能和保持代码可读性之间找平衡很重要：</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#756d59">1</span><span><span style=color:#928374;font-style:italic>// 可能性能稍好，但可读性较差
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#756d59">2</span><span><span style=color:#928374;font-style:italic></span>vec.emplace_back(std<span style=color:#fe8019>::</span>piecewise_construct, 
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#756d59">3</span><span>                 std<span style=color:#fe8019>::</span>forward_as_tuple(<span style=color:#d3869b>1</span>), 
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#756d59">4</span><span>                 std<span style=color:#fe8019>::</span>forward_as_tuple(<span style=color:#b8bb26>&#34;complex&#34;</span>));
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#756d59">5</span><span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#756d59">6</span><span><span style=color:#928374;font-style:italic>// 性能可能稍差，但更易读和维护
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#756d59">7</span><span><span style=color:#928374;font-style:italic></span>vec.push_back(std<span style=color:#fe8019>::</span>make_pair(<span style=color:#d3869b>1</span>, std<span style=color:#fe8019>::</span>string(<span style=color:#b8bb26>&#34;complex&#34;</span>)));
</span></span></code></pre></div><p><strong>7. 结论</strong></p><p>选择<code>push_back</code>还是<code>emplace_back</code>取决于多个因素，包括对象类型、构造复杂度、代码可读性和具体的性能需求。<code>emplace_back</code> 经常被误认为比 <code>push_back</code> 更好，或者与移动语义相关，但这是错误的。在大多数情况下，选择最清晰、最直观的方法通常是最好的做法。</p><p>**建议在日常使用中优先选择<code>push_back</code>。**只有在需要<code>emplace_back</code>的特定功能时（例如，当处理<code>deque&lt;mutex></code>或其他不可移动的类型时），或者在性能确实成为问题时，才考虑使用<code>emplace_back</code>。</p><p><strong>8. 参考链接</strong></p><p>[1] <a href=https://stackoverflow.com/questions/4303513/push-back-vs-emplace-back>https://stackoverflow.com/questions/4303513/push-back-vs-emplace-back</a>
[2] <a href=https://quuxplusone.github.io/blog/2021/03/03/push-back-emplace-back/>https://quuxplusone.github.io/blog/2021/03/03/push-back-emplace-back/</a></p></div></article></main><aside><div><div><h3>LATEST POSTS</h3></div><div><ul><li><a href=/posts/y2024q3-media-summary/>Y2024Q3 影视音总结</a></li><li><a href=/posts/push_back_emplace_back/>C++中的push_back与emplace_back</a></li><li><a href=/posts/y2024q2-media-summary/>Y2024Q2 影视音总结</a></li><li><a href=/posts/cplusplus_security_guide/>C++安全指南</a></li><li><a href=/posts/y2024q1-media-summary/>Y2024Q1 影视音总结</a></li></ul></div></div></aside><footer><p>&copy; 2024 <a href=https://lxulxu.github.io/><b>lxulxu's blog</b></a>.
<a href=https://github.com/lxulxu><b>Github</b></a>.
<a href=https://space.bilibili.com/7739434><b>Bilibili</b></a>.</p></footer></body></html>